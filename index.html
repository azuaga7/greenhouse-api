<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADTEC ¬∑ Invernadero Pro Dashboard</title>
    
    <!-- Scripts Profesionales (Locales) -->
    <script src="libs/react.production.min.js"></script>
    <script src="libs/react-dom.production.min.js"></script>
    <script src="libs/babel.min.js"></script>
    <script src="libs/lucide.min.js"></script>
    <script src="libs/chart.umd.min.js"></script>

    <style>
        
    :root { 
        --adtec-accent: #38bdf8; 
        --bg: #020617; 
        --surface: rgba(15, 23, 42, 0.8); 
        --border: rgba(148, 163, 184, 0.2); 
        --success: #22c55e; 
        --warn: #fbbf24; 
        --danger: #ef4444;
        --text: #f8fafc; 
        --text-muted: #94a3b8;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    .adtec-dashboard-root {
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        min-height: 100vh;
        background: radial-gradient(circle at top, #020617 0, #020617 45%, #000 100%);
        color: #e5e7eb;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    /* LA TARJETA MAESTRA: Copia exacta del Editor */
    .adtec-card { 
        background: linear-gradient(145deg, rgba(15,23,42,0.97), rgba(15,23,42,0.7));
        border-radius: 16px; 
        padding: 25px; 
        position: relative; 
        backdrop-filter: blur(20px);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: 0 18px 45px rgba(15,23,42,0.9);
        display: flex; 
        flex-direction: column;
        overflow: hidden;
    }

    .card-header { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        margin-bottom: 20px; 
        border-bottom: 1px solid rgba(148, 163, 184, 0.2); 
        padding-bottom: 15px; 
    }
    
    .logo-section { display: flex; align-items: center; gap: 12px; }
    .logo-icon { 
        width: 30px; height: 30px; 
        background: #fbbf24; 
        border-radius: 8px;
        display: flex; align-items: center; justify-content: center;
        box-shadow: 0 0 15px rgba(251, 191, 36, 0.4);
    }
    .logo-icon-inner { font-size: 9px; font-weight: 900; color: black; letter-spacing: -0.5px; }
    .card-title { font-weight: 600; font-size: 18px; letter-spacing: 0.05em; color: #f8fafc; margin: 0; }

    .tabs-nav { display: flex; gap: 8px; margin-bottom: 15px; overflow-x: auto; padding-bottom: 5px; width: 100%; justify-content: center; }
    .tab-btn { 
        padding: 10px 20px; cursor: pointer; border-radius: 10px; font-size: 12px; font-weight: 700;
        transition: all 0.2s; color: var(--text-muted); border: 1px solid transparent;
        display: flex; align-items: center; gap: 10px; white-space: nowrap; text-transform: uppercase;
    }
    .tab-btn:hover { background: rgba(255,255,255,0.05); color: var(--text); }
    .tab-btn.active { background: rgba(56, 189, 248, 0.1); border-color: rgba(56, 189, 248, 0.2); color: var(--adtec-accent); }

    .card-body { 
        position: relative; background: rgba(0,0,0,0.2); border-radius: 12px; 
        border: 1px solid rgba(148, 163, 184, 0.1); overflow: hidden; flex: 1;
        display: flex; flex-direction: column;
    }
    .card-body-flat { 
        position: relative; flex: 1; display: flex; flex-direction: column;
    }
    .grid-bg { 
        position: absolute; inset: 0; 
        background-image: radial-gradient(rgba(56, 189, 248, 0.05) 1px, transparent 1px); 
        background-size: 30px 30px; opacity: 0.5; pointer-events: none;
    }

    .widgets-area { position: relative; width: 100%; height: 100%; z-index: 1; flex: 1; }

    /* LOS WIDGETS: Copia exacta del Editor */
    .adtec-status-item { 
        position: absolute; padding: 12px 14px; border-radius: 12px;
        background: radial-gradient(circle at top, rgba(15,118,110,0.15), rgba(15,23,42,0.96));
        border: 1px solid rgba(45,212,191,0.2);
        display: flex; flex-direction: column; gap: 4px;
        transition: all 0.3s ease; backdrop-filter: blur(5px);
    }
    .adtec-status-item h3 { font-size: 10px; text-transform: uppercase; letter-spacing: 0.08em; color: #9ca3af; margin: 0; font-weight: 700; }
    .adtec-status-value { font-size: 20px; font-weight: 700; color: var(--adtec-accent); }
    .adtec-status-sub { font-size: 10px; color: #9ca3af; }
    
    .adtec-temp-bar { 
        width: 100%; height: 6px; background: rgba(15,23,42,0.8); 
        border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 4px; 
        overflow: hidden; margin-top: 5px; position: relative; 
    }
    .adtec-temp-bar-fill { 
        height: 100%; width: 0%; background: var(--adtec-accent);
        box-shadow: 0 0 10px rgba(56, 189, 248, 0.4);
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); 
    }

    .adtec-status-chip { 
        display: inline-flex; align-items: center; gap: 6px; padding: 3px 10px; 
        border-radius: 999px; font-size: 10px; font-weight: 700; margin-top: auto; 
        border: 1px solid rgba(148, 163, 184, 0.3); text-transform: uppercase; letter-spacing: 0.5px;
    }
    .adtec-status-chip.on { background: rgba(34,197,94,0.1); color: #22c55e; border-color: rgba(34,197,94,0.4); }
    .adtec-status-chip.warn { background: rgba(251,191,36,0.1); color: #fbbf24; border-color: rgba(251,191,36,0.4); }
    .adtec-status-chip.off { background: rgba(239,68,68,0.1); color: #ef4444; border-color: rgba(239,68,68,0.4); }
    
    .adtec-status-dot { width: 7px; height: 7px; border-radius: 50%; background: #9ca3af; }
    .adtec-status-dot.on { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
    .adtec-status-dot.warn { background: #fbbf24; box-shadow: 0 0 10px #fbbf24; }
    .adtec-status-dot.off { background: #ef4444; box-shadow: 0 0 10px #ef4444; }

    .vfd-btn { 
        flex: 1; padding: 6px; border-radius: 4px; 
        border: 1px solid rgba(255,255,255,0.1); color: white; 
        font-weight: 800; font-size: 10px; cursor: pointer; 
        transition: all 0.2s; background: rgba(255,255,255,0.05);
        text-transform: uppercase; letter-spacing: 0.05em;
        display: inline-flex; align-items: center; justify-content: center; gap: 4px;
    }
    .vfd-btn:hover { background: rgba(255,255,255,0.1); }
    .vfd-btn:active { transform: scale(0.98); }
    .vfd-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .vfd-btn.start { background: rgba(34, 197, 94, 0.2); color:rgb(214, 245, 245); border-color: #22c55e; }
    .vfd-btn.stop { background: rgba(239, 68, 68, 0.2); color:rgb(255, 204, 204); border-color: #ef4444; }

    .adtec-security-banner {
        margin-top: 25px; padding: 15px 20px; 
        background: rgba(250,204,21,0.05); border-radius: 10px; 
        border: 1px solid rgba(250,204,21,0.2); display: flex; 
        gap: 15px; alignItems: center;
    }
    .adtec-security-banner p { margin: 0; fontSize: 11px; color: #fbbf24; lineHeight: 1.5; }


    .vfd-dial {
        width: 100px; height: 100px; border-radius: 50%; border: 6px solid #1e293b; 
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        background: rgba(0,0,0,0.2); transition: all 0.3s ease; position: relative;
    }
    .vfd-dial.on { border-top-color: var(--adtec-accent); box-shadow: 0 0 15px rgba(56,189,248,0.2); }
    .vfd-dial-value { font-size: 18px; font-weight: 900; color: white; }
    .vfd-dial.on .vfd-dial-value { color: var(--adtec-accent); }
    .vfd-dial-unit { font-size: 8px; color: #9ca3af; }

    .switch { position: relative; display: inline-block; width: 38px; height: 22px; transform: scale(0.7); }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { 
        position: absolute; cursor: pointer; inset: 0; 
        background-color: rgba(148, 163, 184, 0.2); transition: .2s; border-radius: 22px; 
    }
    .slider:before { 
        position: absolute; content: ""; height: 16px; width: 16px; 
        left: 3px; bottom: 3px; background-color: white; transition: .2s; border-radius: 50%; 
    }
    input:checked + .slider { background-color: var(--adtec-accent); }
    input:checked + .slider:before { transform: translateX(16px); }

    .gsm-bars { display: flex; gap: 2px; align-items: flex-end; height: 20px; }
    .gsm-bar { width: 3px; background: rgba(255,255,255,0.1); border-radius: 1px; }
    .gsm-bar.active { background: var(--adtec-accent); box-shadow: 0 0 8px var(--adtec-accent); }

    .adtec-label-widget {
        pointer-events: none; white-space: pre-wrap; font-family: 'Segoe UI', sans-serif;
        display: flex; align-items: center; justify-content: center; text-align: center;
    }

    .adtec-sparkline-container {
        width: 100%;
        height: 45px;
        margin-top: 12px;
        overflow: visible;
        position: relative;
    }
    /* Punto 2: Removido para usar motor real */
    .adtec-sparkline-svg {
        width: 100%;
        height: 100%;
        display: block;
    }
    .adtec-sparkline-path {
        fill: none;
        stroke-width: 1.5;
        stroke-linecap: round;
        stroke-linejoin: round;
        vector-effect: non-scaling-stroke;
    }

    .alert-badge {
        background: #ef4444;
        color: white;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 10px;
        position: absolute;
        top: -5px;
        right: -5px;
        box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        animation: pulse 2s infinite;
        font-weight: 800;
        z-index: 10;
    }

    .alert-card-item {
        background: rgba(30, 41, 59, 0.5);
        border-radius: 12px;
        display: flex;
        overflow: hidden;
        border: 1px solid rgba(148, 163, 184, 0.1);
        transition: transform 0.2s;
    }
    
    .alert-card-side {
        width: 6px;
        background: #ef4444;
        flex-shrink: 0;
    }

    .alert-card-content {
        padding: 16px;
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .alert-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .alert-card-tag {
        background: #ef4444;
        color: white;
        font-size: 9px;
        font-weight: 900;
        padding: 2px 8px;
        border-radius: 4px;
        letter-spacing: 0.05em;
    }

    .alert-card-time {
        font-size: 11px;
        color: #94a3b8;
    }

    .alert-card-msg {
        font-size: 16px;
        font-weight: 700;
        color: #f8fafc;
    }

    .alert-card-detail {
        font-size: 12px;
        color: #94a3b8;
    }

    @keyframes pulse {
        0% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.1); opacity: 0.8; }
        100% { transform: scale(1); opacity: 1; }
    }

    /* Definici√≥n Global de Degradados por Porcentaje */
    .gauge-gradient-normal {
        --grad-start: var(--gauge-pct-0, #10b981);
        --grad-mid: var(--gauge-pct-50, #f59e0b);
        --grad-end: var(--gauge-pct-100, #ef4444);
    }

    .gauge-gradient-inverted {
        --grad-start: var(--gauge-pct-100, #ef4444);
        --grad-mid: var(--gauge-pct-50, #f59e0b);
        --grad-end: var(--gauge-pct-0, #10b981);
    }

        body { 
            margin: 0; 
            padding: 0; 
            background: #020617; 
            overflow-x: hidden; 
        }
    </style>
</head>
<body>
    <div id="dashboard-root"></div>
    
    <!-- Sistema de Diagn√≥stico de Errores -->
    <div id="error-fallback" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#0f172a; color:#f8fafc; font-family:sans-serif; padding:40px; box-sizing:border-box; z-index:9999;">
        <h1 style="color:#ef4444; margin-bottom:20px;">‚ùå Error de Renderizado</h1>
        <p style="font-size:18px; line-height:1.6;">El dashboard no pudo iniciarse correctamente. Esto suele deberse a un error en la configuraci√≥n o un problema en el script de React.</p>
        <div id="error-details" style="background:#1e293b; padding:20px; border-radius:12px; border:1px solid #334155; margin-top:20px; font-family:monospace; white-space:pre-wrap; color:#94a3b8; max-height:400px; overflow-y:auto;"></div>
        <button onclick="window.location.reload()" style="margin-top:30px; padding:12px 25px; background:#38bdf8; color:#0f172a; border:none; border-radius:8px; font-weight:bold; cursor:pointer;">REINTENTAR CARGA</button>
    </div>

    <script type="text/babel">
        try {
            
        const CONFIG = {
            dashboard: {"tabs":[{"id":"1","name":"Estado Actual","icon":"layout-dashboard","title":"Estado Actual del Invernadero","width":970,"height":816,"type":"dashboard"},{"id":"5","name":"Laboratorio de GR√°ficos","icon":"activity","title":"Laboratorio de Gr√°ficos","width":1000,"height":700,"type":"charts"},{"id":"3","name":"Control","icon":"gamepad-2","title":"Control Remoto de Invernadero","width":700,"height":800,"type":"control"},{"id":"4","name":"Alertas","icon":"bell","title":"Alertas","width":1000,"height":700,"type":"alerts"}],"widgets":[{"id":"w_1768270825285","type":"gauge","label":"Humedad del Invernadero","key":"dht22_1_HUM_OUT","unit":"%","min":0,"max":100,"x":240,"y":10,"w":220,"h":180,"tabId":"1","format":"fixed1","showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270831388","type":"gauge","label":"Temperatura del Invernadero","key":"dht22_1_TEMP_OUT","unit":"¬∞C","min":0,"max":50,"x":10,"y":10,"w":220,"h":180,"tabId":"1","format":"fixed1","showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270903173","type":"gauge","label":"Temperatura Exterior","key":"ds18b20_2_TEMP_OUT","unit":"¬∞C","min":0,"max":50,"x":10,"y":210,"w":220,"h":180,"tabId":"1","format":"fixed1","showSparkline":true,"showMinMax":true,"inverted":false,"hideKey":true},{"id":"w_1768270908326","type":"gauge","label":"Temperatura de Pozo","key":"ds18b20_1_TEMP_OUT","unit":"¬∞C","min":0,"max":50,"x":240,"y":210,"w":220,"h":180,"tabId":"1","format":"fixed1","showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270938829","type":"gauge","label":"Frecuencia Ventiladores Pared","key":"vfd_1_FREQ_OUT","unit":"Hz","min":0,"max":70,"x":10,"y":410,"w":220,"h":180,"tabId":"1","format":"fixed1","inverted":false,"showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270972142","type":"gauge","label":"Luxes","key":"tsl2561_1_LUX_OUT","unit":"LX","min":0,"max":40000,"x":240,"y":410,"w":220,"h":180,"tabId":"1","format":"fixed1","showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270996596","type":"indicator","label":"Estado Bomba de Agua","key":"relay_3_STATE_OUT","min":0,"max":100,"x":500,"y":120,"w":180,"h":80,"tabId":"1","format":"bool_onoff","hideKey":true},{"id":"w_1768271000492","type":"location","label":"GPS","key":"gsm_1_LOCATION","min":0,"max":100,"x":710,"y":600,"w":200,"h":85,"tabId":"1","format":"fixed1","hideKey":true},{"id":"w_1768271019292","type":"indicator","label":"Estado de Ventiladores Axiales","key":"vfd_1_STATE_OUT","min":0,"max":100,"x":500,"y":450,"w":180,"h":80,"tabId":"1","format":"bool_onoff","hideKey":true},{"id":"w_1768271019940","type":"indicator","label":"Estado Vent. 2","key":"relay_2_STATE_OUT","min":0,"max":100,"x":500,"y":340,"w":180,"h":80,"tabId":"1","format":"bool_onoff","hideKey":true},{"id":"w_1768271020388","type":"indicator","label":"Estado Vent. 1","key":"relay_1_STATE_OUT","min":0,"max":100,"x":500,"y":230,"w":180,"h":80,"tabId":"1","format":"bool_onoff","hideKey":true},{"id":"w_1768271034349","type":"text","label":"Uso Ventiladores Axiales","key":"vfd_1_RUNTIME_OUT","unit":"Hs","min":0,"max":100,"x":700,"y":450,"w":200,"h":90,"tabId":"1","format":"time_hm","hideKey":true,"showMinMax":true},{"id":"w_1768271034900","type":"text","label":"Uso Ventiladores 3 - 4","key":"relay_2_RUNTIME_OUT","unit":"Hs","min":0,"max":100,"x":700,"y":340,"w":200,"h":90,"tabId":"1","format":"time_hm","hideKey":true,"showMinMax":true},{"id":"w_1768271035300","type":"text","label":"Uso Ventiladores 1 - 2","key":"relay_1_RUNTIME_OUT","unit":"Hs","min":0,"max":100,"x":700,"y":230,"w":200,"h":90,"tabId":"1","format":"time_hm","hideKey":true,"showMinMax":true},{"id":"w_1768271035668","type":"text","label":"Uso Bomba de Agua","key":"relay_3_RUNTIME_OUT","unit":"Hs","min":0,"max":100,"x":700,"y":120,"w":200,"h":90,"tabId":"1","format":"time_hm","hideKey":true,"showMinMax":true},{"id":"w_1768271685572","type":"control-relay","label":"Estado Bomba de Agua","key":"relay_3_STATE_OUT","target":"relay_3","min":0,"max":100,"x":30,"y":10,"w":220,"h":120,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768271690253","type":"control-relay","label":"Estado Vent. 1","key":"relay_1_STATE_OUT","target":"relay_1","min":0,"max":100,"x":30,"y":140,"w":220,"h":120,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768271692422","type":"control-relay","label":"Estado Vent. 2","key":"relay_2_STATE_OUT","target":"relay_2","min":0,"max":100,"x":30,"y":270,"w":220,"h":120,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768271697991","type":"control-vfd","label":"Frecuencia Ventiladores Pared","key":"vfd_1_FREQ_OUT","target":"vfd_1","min":0,"max":100,"x":330,"y":110,"w":260,"h":280,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768272928661","type":"control-relay","label":"Estado de Ventiladores Axiales","key":"vfd_1_STATE_OUT","target":"vfd_1","min":0,"max":100,"x":30,"y":400,"w":220,"h":120,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768842671728","type":"text","label":"Ultima Alerta","key":"sin_key","unit":"","min":0,"max":0,"x":10,"y":600,"w":680,"h":90,"tabId":"1","format":"fixed1","borderRadius":12,"boxShadow":"0 0 10px","showBar":false,"hideKey":true},{"id":"w_1768844189895","type":"datetime","label":"Reloj Sistema","key":"timestamp","unit":"Hs","min":0,"max":0,"x":490,"y":10,"w":220,"h":85,"tabId":"1","format":"datetime_hm_full","borderRadius":12,"boxShadow":"0 0 10px","showBar":false,"hideKey":true},{"id":"w_1768844223684","type":"connection","label":"Estado Red","key":"gsm_signal","min":0,"max":0,"x":720,"y":10,"w":180,"h":85,"tabId":"1","format":"fixed1","borderRadius":12,"boxShadow":"0 0 10px","showBar":false,"signalKey":"gsm_1_SIGNAL","statusKey":"gsm_1_STATE","hideKey":true}],"variables":[{"key":"dht22_1_HUM_OUT","label":"Humedad del Invernadero","dataType":"HUM"},{"key":"dht22_1_TEMP_OUT","label":"Temperatura del Invernadero","dataType":"TEMP"},{"key":"ds18b20_2_TEMP_OUT","label":"Temperatura Exterior","dataType":"TEMP"},{"key":"relay_3_STATE_OUT","label":"Estado Bomba de Agua","dataType":"STATE"},{"key":"relay_1_STATE_OUT","label":"Estado Vent. 1","dataType":"STATE"},{"key":"relay_2_STATE_OUT","label":"Estado Vent. 2","dataType":"STATE"},{"key":"vfd_1_FREQ_OUT","label":"Frecuencia Ventiladores Pared","dataType":""},{"key":"relay_3_RUNTIME_OUT","label":"Uso Bomba de Agua","dataType":""},{"key":"relay_1_RUNTIME_OUT","label":"Uso Ventiladores 1 - 2","dataType":""},{"key":"relay_2_RUNTIME_OUT","label":"Uso Ventiladores 3 - 4","dataType":""},{"key":"vfd_1_STATE_OUT","label":"Estado de Ventiladores Axiales","dataType":"STATE"},{"key":"vfd_1_RUNTIME_OUT","label":"Uso Ventiladores Axiales","dataType":""},{"key":"ds18b20_1_TEMP_OUT","label":"Temperatura de Pozo","dataType":"TEMP"},{"key":"tsl2561_1_LUX_OUT","label":"Luxes","dataType":"LUX"},{"key":"gsm_1_SIGNAL","label":"Signal GSM","dataType":"SIGNAL"},{"key":"gsm_1_STATE","label":"Estado GSM","dataType":"STATE"},{"key":"gsm_1_LOCATION","label":"GPS","dataType":"LOCATION"}],"actuators":[{"id":"relay_1","label":"relay_1","type":"ACT_RELAY_SINGLE"},{"id":"relay_2","label":"relay_2","type":"ACT_RELAY_SINGLE"},{"id":"vfd_1","label":"vfd_1","type":"ACT_VFD_MODBUS"},{"id":"relay_3","label":"relay_3","type":"ACT_RELAY_SINGLE"}]},
            labels: {"dht22_1_HUM_OUT":"Humedad del Invernadero","dht22_1_TEMP_OUT":"Temperatura del Invernadero","ds18b20_2_TEMP_OUT":"Temperatura Exterior","relay_3_STATE_OUT":"Estado Bomba de Agua","relay_1_STATE_OUT":"Estado Vent. 1","relay_2_STATE_OUT":"Estado Vent. 2","vfd_1_FREQ_OUT":"Frecuencia Ventiladores Pared","relay_3_RUNTIME_OUT":"Uso Bomba de Agua","relay_1_RUNTIME_OUT":"Uso Ventiladores 1 - 2","relay_2_RUNTIME_OUT":"Uso Ventiladores 3 - 4","vfd_1_STATE_OUT":"Estado de Ventiladores Axiales","vfd_1_RUNTIME_OUT":"Uso Ventiladores Axiales","ds18b20_1_TEMP_OUT":"Temperatura de Pozo","tsl2561_1_LUX_OUT":"Luxes","gsm_1_SIGNAL":"Signal GSM","gsm_1_STATE":"Estado GSM","gsm_1_LOCATION":"GPS"},
            refreshInterval: 1000,
            chartConfig: {
                primaryY: '',
                secondaryY: '',
                timeRange: 'Ahora'
            }
        };
        
        const formatValue = (val, format, unit = "") => {
            if (val === null || val === undefined || val === '--') return "--";
            
            const num = parseFloat(val);
            const isNum = !isNaN(num);
            if (!isNum) return val + unit;

            // BLINDAJE PUNTO 4: Si es el valor centinela de error, no mostrar n√∫mero
            if (num === -50.0) return "--";

            if (format === 'fixed1') return num.toFixed(1) + unit;
            if (format === 'fixed2') return num.toFixed(2) + unit;
            
            const isDateStr = typeof val === 'string' && (val.includes('T') || (val.includes('-') && val.includes(':')));

            // Formatos de Tiempo y Fecha
            if (format?.startsWith('datetime') || ((format === 'time_hm' || format === 'time_hms') && isDateStr)) {
                try {
                    const d = new Date(val);
                    if (!isNaN(d.getTime())) {
                        const showSeconds = format === 'time_hms' || format === 'datetime_full' || format === 'raw';
                        const time = d.toLocaleTimeString('es-ES', { 
                            hour: '2-digit', minute: '2-digit', 
                            second: showSeconds ? '2-digit' : undefined 
                        });
                        const dateStr = d.toLocaleDateString('es-ES', { weekday: 'long', day: '2-digit', month: 'long', year: 'numeric' });
                        const date = dateStr.charAt(0).toUpperCase() + dateStr.slice(1);
                        
                        if (format === 'datetime_full' || format === 'datetime_hm_full') return time + "|" + date;
                        return time;
                    }
                } catch (e) { }
            }

            if (format === 'time_hm' || format === 'time_hms') {
                if (!isNum) return "--"; // Validar que sea num√©rico para formatos de tiempo
                const totalSeconds = Math.floor(num);
                const h = Math.floor(totalSeconds / 3600);
                const m = Math.floor((totalSeconds % 3600) / 60);
                const s = totalSeconds % 60;
                if (format === 'time_hm') return h + ":" + m.toString().padStart(2, '0');
                return h + ":" + m.toString().padStart(2, '0') + ":" + s.toString().padStart(2, '0');
            }

            if (format === 'datetime' || (typeof val === 'string' && val.includes('T') && val.includes(':'))) {
                try {
                    const date = new Date(val);
                    if (!isNaN(date.getTime())) {
                        return date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    }
                } catch (e) { }
            }
            
            if (format === 'bool_onoff') {
                const isTrue = val === true || val === 1 || val === '1' || val === '1.00' || 
                               String(val).toUpperCase() === 'ON' || String(val).toUpperCase() === 'TRUE' || 
                               String(val).toUpperCase() === 'ACTIVO';
                return isTrue ? 'ON' : 'OFF';
            }

            if (format === 'percent') {
                if (!isNum) return "--";
                return num.toFixed(0) + "%";
            }

            if (isNum && typeof val === 'number') {
                return num.toFixed(1) + unit;
            }
            
            if (typeof val === 'string' && val.includes(',')) {
                return val + unit;
            }

            // Si llegamos aqu√≠ y no es num√©rico ni un formato especial, devolvemos --
            if (!isNum && val !== '--') return "--";

            return val + unit;
        };

        const getGaugeColor = (val, key = "") => {
            const num = parseFloat(val);
            if (isNaN(num)) return '#10b981';
            if (key.toLowerCase().includes('temp')) {
                if (num < 15) return '#3b82f6';
                if (num < 30) return '#10b981';
                if (num < 35) return '#f59e0b';
                return '#ef4444';
            }
            if (key.toLowerCase().includes('hum')) {
                if (num < 40) return '#ef4444';
                if (num < 70) return '#10b981';
                return '#f59e0b';
            }
            if (num < 20) return '#10b981';
            if (num < 80) return '#f59e0b';
            return '#ef4444';
        };

        const getGradientByType = (type, alpha, inverted) => {
            let stops = [{ pos: 0, color: '#10b981' }, { pos: 50, color: '#f59e0b' }, { pos: 100, color: '#ef4444' }];
            if (inverted) {
                const colors = stops.map(s => s.color).reverse();
                stops = stops.map((s, i) => ({ ...s, color: colors[i] }));
            }
            const alphaHex = Math.floor(alpha * 255).toString(16).padStart(2, '0');
            return "linear-gradient(90deg, " + stops.map(s => s.color + alphaHex + " " + s.pos + "%").join(", ") + ")";
        };

        // Motor de Minigr√°ficos (Sparkline Engine)
        const SparklineEngine = {
            memory: {},
            BUFFER_SIZE: 100, // Reducido de 750 a 100
            getSafeRange(min, max) {
                const sMin = Number(min) || 0;
                let sMax = Number(max) || 100;
                if (sMax <= sMin) sMax = sMin + 1;
                return { min: sMin, max: sMax, mid: (sMin + sMax) / 2 };
            },
            getBuffer(id, variableKey, min, max) {
                const { mid, min: sMin, max: sMax } = this.getSafeRange(min, max);
                if (!this.memory[id] || this.memory[id].variableKey !== variableKey) {
                    this.memory[id] = {
                        data: new Array(this.BUFFER_SIZE).fill(mid),
                        variableKey: variableKey,
                        hasData: false,
                        lastMin: sMin,
                        lastMax: sMax,
                        dailyMin: undefined,
                        dailyMax: undefined
                    };
                } else {
                    // DETECTAR CAMBIO DE ESCALA EN CALIENTE
                    const buffer = this.memory[id];
                    if (buffer.lastMin !== sMin || buffer.lastMax !== sMax) {
                        const oldMin = buffer.lastMin !== undefined ? buffer.lastMin : 0;
                        const oldMax = buffer.lastMax !== undefined ? buffer.lastMax : 100;
                        const oldRange = Math.max(1, oldMax - oldMin);
                        const newRange = Math.max(1, sMax - sMin);

                        buffer.data = buffer.data.map(val => {
                            const pct = (val - oldMin) / oldRange;
                            return sMin + (pct * newRange);
                        });

                        buffer.lastMin = sMin;
                        buffer.lastMax = sMax;
                    }
                }
                return this.memory[id].data;
            },
            hasRealData(id) {
                return this.memory[id] && this.memory[id].hasData;
            },
            getStats(id) {
                return {
                    min: this.memory[id] ? this.memory[id].dailyMin : undefined,
                    max: this.memory[id] ? this.memory[id].dailyMax : undefined
                };
            },
            // Guardar historial completo en formato [{timestamp, kv}]
            setHistory(id, variableKey, historyRows, min, max) {
                const buffer = this.getBuffer(id, variableKey, min, max);
                const { mid, min: sMin, max: sMax } = this.getSafeRange(min, max);
                if (!historyRows || historyRows.length === 0) return;

                // Registrar primer timestamp conocido para referencias (no inventar horas)
                if (historyRows[0] && historyRows[0].timestamp) this._firstHistoryTimestamp = historyRows[0].timestamp;

                this.memory[id].lastMin = sMin;
                this.memory[id].lastMax = sMax;

                let hMin = Infinity;
                let hMax = -Infinity;

                const incoming = historyRows.map(row => {
                    const raw = (row && row.kv) ? (row.kv[variableKey] ?? row.kv['kv.' + variableKey]) : (row ? (row[variableKey] ?? row['kv.' + variableKey]) : undefined);
                    const num = parseFloat(raw);
                    const val = isNaN(num) ? sMin : Math.max(sMin, Math.min(sMax, num));
                    if (!isNaN(num)) {
                        hMin = Math.min(hMin, num);
                        hMax = Math.max(hMax, num);
                    }
                    return val;
                }).slice(-this.BUFFER_SIZE);

                if (hMin !== Infinity) {
                    if (this.memory[id].dailyMin === undefined) {
                        this.memory[id].dailyMin = hMin;
                        this.memory[id].dailyMax = hMax;
                    } else {
                        this.memory[id].dailyMin = Math.min(this.memory[id].dailyMin, hMin);
                        this.memory[id].dailyMax = Math.max(this.memory[id].dailyMax, hMax);
                    }
                }

                if (incoming.length > 0) {
                    buffer.fill(mid);
                    const startIdx = this.BUFFER_SIZE - incoming.length;
                    for (let i = 0; i < incoming.length; i++) {
                        buffer[startIdx + i] = incoming[i];
                    }
                    this.memory[id].hasData = true;
                }
            },
            // Devuelve el primer timestamp almacenado por setHistory o null si no existe
            getTodayStartISO() {
                return this._firstHistoryTimestamp || null;
            },
            update(id, variableKey, newValue, min, max) {
                const buffer = this.getBuffer(id, variableKey, min, max);
                const { min: sMin, max: sMax } = this.getSafeRange(min, max);
                
                this.memory[id].lastMin = sMin;
                this.memory[id].lastMax = sMax;

                let val = parseFloat(newValue);
                const isInvalid = newValue === null || newValue === undefined || newValue === '' || isNaN(val);
                if (isInvalid) {
                    // Mantenemos el √∫ltimo valor para evitar saltos a 0 (especialmente en Luxes)
                    val = buffer[buffer.length - 1];
                } else {
                    val = Math.max(sMin, Math.min(sMax, val));
                    
                    const current = parseFloat(newValue);
                    if (!isNaN(current)) {
                        if (this.memory[id].dailyMin === undefined) {
                            this.memory[id].dailyMin = current;
                            this.memory[id].dailyMax = current;
                        } else {
                            this.memory[id].dailyMin = Math.min(this.memory[id].dailyMin, current);
                            this.memory[id].dailyMax = Math.max(this.memory[id].dailyMax, current);
                        }
                    }
                }
                
                buffer.shift();
                buffer.push(val);
                this.memory[id].hasData = true;
                
                return buffer;
            }
        };

        const getRawWidgetValue = (key, state) => {
            if (!state) return undefined;
            let val = state.telemetry ? state.telemetry[key] : state[key];
            if (val === undefined && state.data && typeof state.data === 'object') val = state.data[key];
            if (val === undefined && state.blocks) {
                for (const blockId in state.blocks) {
                    if (state.blocks[blockId][key] !== undefined) {
                        val = state.blocks[blockId][key];
                        break;
                    }
                }
            }
            if (val === undefined && key.includes('.')) {
                const [blockId, prop] = key.split('.');
                const block = state.blocks && state.blocks[blockId];
                val = block && (block[prop.toLowerCase()] || block[prop]);
            }
            return val;
        };

        const getWidgetValueShared = (key, state, widgets) => {
            if (!state) return '--';
            if (key.toLowerCase() === 'alert_msg' || key.toLowerCase() === 'ultima_alerta' || key.toLowerCase() === 'alerta') {
                const alerts = state.activeAlerts || [];
                if (alerts.length === 0) return 'üü¢ SISTEMA OK';
                const lastAlert = alerts[alerts.length - 1];
                return (lastAlert.type === 'CRITICAL' ? 'üî¥' : 'üü°') + ' ' + lastAlert.message;
            }
            const val = getRawWidgetValue(key, state);
            if (val === undefined) return '--';
            const widget = widgets.find(w => w.key === key);
            return formatValue(val, widget && widget.format, widget && widget.unit);
        };
  
            
const { useState, useEffect, useMemo, useRef, useCallback } = React;

// Componente de Gr√°fico Optimizado (Zero-Flicker)
const DashboardChart = React.memo(({ widget, dataHistory, chartConfig }) => {
    const canvasRef = useRef(null);
    const chartRef = useRef(null);

    // Obtener configuraci√≥n de escala (min/max) y formato
    const getScaleSettings = (key) => {
        if (!key) return { min: undefined, max: undefined, format: undefined, unit: "" };
        const w = CONFIG.dashboard.widgets.find(w => w.key === key);
        if (!w) return { min: undefined, max: undefined, format: undefined, unit: "" };
        
        // Si es estado digital, escala inicial 0-2
        if (w.format === 'bool_onoff' || w.type === 'indicator' || w.type === 'control-relay') {
            return { min: 0, max: 2, format: 'bool_onoff', unit: w.unit || "" };
        }

        const hasNoLimits = (w.min === 0 && w.max === 0) || (w.min === undefined && w.max === undefined);
        return { 
            min: hasNoLimits ? undefined : w.min, 
            max: hasNoLimits ? undefined : w.max,
            format: w.format,
            unit: w.unit || ""
        };
    };

    useEffect(() => {
        if (!canvasRef.current || typeof Chart === 'undefined') return;

        const ctx = canvasRef.current.getContext('2d');
        const pS = getScaleSettings(chartConfig && chartConfig.primaryY);
        const sS = getScaleSettings(chartConfig && chartConfig.secondaryY);

        chartRef.current = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Eje Principal',
                        data: [],
                        borderColor: '#38bdf8',
                        backgroundColor: 'rgba(56, 189, 248, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Eje Secundario',
                        data: [],
                        borderColor: '#a855f7',
                        backgroundColor: 'rgba(168, 85, 247, 0.05)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.3,
                        pointRadius: 0,
                        yAxisID: 'y1',
                        hidden: !(chartConfig && chartConfig.secondaryY)
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: { 
                        display: true,
                        grid: { color: 'rgba(255,255,255,0.03)' },
                        ticks: { 
                            color: '#64748b', 
                            font: { size: 9 },
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 8 
                        }
                    },
                    y: {
                        display: true,
                        position: 'left',
                        beginAtZero: false,
                        suggestedMin: pS.min,
                        suggestedMax: pS.max,
                        grid: { color: 'rgba(255,255,255,0.05)' }, 
                        ticks: { 
                            color: '#38bdf8', 
                            font: { size: 10 },
                            callback: (val) => formatValue(val, pS.format, "")
                        } 
                    },
                    y1: {
                        display: !!(chartConfig && chartConfig.secondaryY),
                        position: 'right',
                        beginAtZero: false,
                        suggestedMin: sS.min,
                        suggestedMax: sS.max,
                        grid: { drawOnChartArea: false }, 
                        ticks: { 
                            color: '#a855f7', 
                            font: { size: 10 },
                            callback: (val) => formatValue(val, sS.format, "")
                        }
                    }
                },
                    plugins: { 
                        legend: { 
                            display: true,
                            position: 'top',
                            align: 'end',
                            labels: {
                                color: '#f8fafc',
                                font: { size: 11, weight: 'bold' },
                                usePointStyle: true,
                                pointStyle: 'rectRounded',
                                padding: 15
                            }
                        },
                        tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(15, 23, 42, 0.95)',
                        titleColor: '#fff',
                        titleFont: { size: 11, weight: 'bold' },
                        bodyFont: { size: 12 },
                        padding: 10,
                        borderColor: 'rgba(255,255,255,0.1)',
                        borderWidth: 1,
                        callbacks: {
                            title: (items) => {
                                const item = items[0];
                                const rawData = dataHistory[item.dataIndex];
                                if (!rawData || !rawData.fullTimestamp) return item.label;
                                const d = new Date(rawData.fullTimestamp);
                                return d.toLocaleDateString('es-ES') + ' ' + d.toLocaleTimeString('es-ES');
                            },
                            label: (item) => {
                                const label = item.dataset.label || '';
                                const value = item.formattedValue;
                                const unitKey = (item.datasetIndex === 0 ? (chartConfig && chartConfig.primaryY) : (chartConfig && chartConfig.secondaryY));
                                const widgetFound = CONFIG.dashboard.widgets.find(w => w.key === unitKey);
                                const unit = (widgetFound && widgetFound.unit) || '';
                                return label + ': ' + value + ' ' + unit;
                            }
                        }
                    }
                }
            }
        });

        return () => {
            if (chartRef.current) chartRef.current.destroy();
        };
    }, []);

    useEffect(() => {
        const chart = chartRef.current;
        if (!chart || !chartConfig || !chartConfig.primaryY) return;
        
        const pS = getScaleSettings(chartConfig.primaryY);
        const sS = getScaleSettings(chartConfig.secondaryY);

        // Actualizar nombres de variables
        const v1Label = CONFIG.labels[chartConfig.primaryY] || chartConfig.primaryY || 'Variable 1';
        const v2Label = CONFIG.labels[chartConfig.secondaryY] || chartConfig.secondaryY || 'Variable 2';

        const safeHistory = dataHistory || [];
        chart.data.labels = safeHistory.map(d => d.t);
        chart.data.datasets[0].data = safeHistory.map(d => d.v);
        chart.data.datasets[0].label = v1Label;

        if (chartConfig.secondaryY) {
            chart.data.datasets[1].data = dataHistory.map(d => d.v2);
            chart.data.datasets[1].label = v2Label;
            chart.data.datasets[1].hidden = false;
            chart.options.scales.y1.display = true;
        } else {
            chart.data.datasets[1].hidden = true;
            chart.options.scales.y1.display = false;
        }

        // Actualizar l√≠mites din√°micamente con auto-escalado (suggested)
        chart.options.scales.y.suggestedMin = pS.min;
        chart.options.scales.y.suggestedMax = pS.max;
        chart.options.scales.y.ticks.callback = (val) => formatValue(val, pS.format, "");

        if (chartConfig && chartConfig.secondaryY) {
            chart.options.scales.y1.suggestedMin = sS.min;
            chart.options.scales.y1.suggestedMax = sS.max;
            chart.options.scales.y1.ticks.callback = (val) => formatValue(val, sS.format, "");
        }

        chart.update('none');
    }, [dataHistory, chartConfig]);

    return <canvas ref={canvasRef} style={{ display: 'block', width: '100%', height: '100%' }} />;
});

// Componente de Minigr√°fico (Sparkline) - Motor Pro de 100 puntos
const Sparkline = React.memo(({ id, variableKey, min, max, inverted, value, historyTick }) => {
    // Estado local para asegurar dibujo sincronizado
    const [points, setPoints] = useState(() => {
        const initial = SparklineEngine.getBuffer(id, variableKey, min, max);
        return [...initial];
    });

    useEffect(() => {
        // Solo obtener el buffer actual
        // El motor es actualizado de forma centralizada en fetchUpdate y fetchHistory
        const currentPoints = SparklineEngine.getBuffer(id, variableKey, min, max);
        setPoints([...currentPoints]);
    }, [id, variableKey, value, min, max, historyTick]);

    const hasData = useMemo(() => SparklineEngine.hasRealData(id), [id, value, historyTick]);
    const isDisconnected = value === undefined || value === null || value === '' || isNaN(parseFloat(value));

    const pathData = useMemo(() => {
        if (points.length === 0) return "";
        const width = 100;
        const height = 50;
        // Ajuste de margen para visibilidad de Luxes y valores m√≠nimos
        const padding = 4; 
        const safeHeight = height - (padding * 2);
        
        // Sincronizar con motor
        const sMin = Number(min) || 0;
        let sMax = Number(max);
        if (isNaN(sMax)) sMax = 100;
        if (sMax <= sMin) sMax = sMin + 1;
        const range = sMax - sMin;
        
        return points.map((val, i) => {
            const x = (i / (points.length - 1)) * width;
            // Blindaje: fijar al borde si excede (dentro del √°rea segura)
            const cappedVal = Math.max(sMin, Math.min(sMax, val));
            const pct = (cappedVal - sMin) / range;
            const y = (height - padding) - (pct * safeHeight);
            return (i === 0 ? 'M' : 'L') + " " + x + " " + y;
        }).join(' ');
    }, [points, min, max]);

    // Color de la l√≠nea: Degradado real por defecto. Azul de Diagn√≥stico SOLO si hubo datos y se perdieron.
    const strokeColor = (hasData && isDisconnected) ? "#3b82f6" : "url(#grad-final-" + id + ")";

    // Asegurar que las variables de color existan para el degradado
    const sparklineColors = {
        '--grad-start': inverted ? '#ef4444' : '#10b981',
        '--grad-mid': '#f59e0b',
        '--grad-end': inverted ? '#10b981' : '#ef4444'
    };

    return React.createElement('div', { 
        className: 'adtec-sparkline-container ' + (inverted ? 'gauge-gradient-inverted' : 'gauge-gradient-normal'),
        style: { 
            marginTop: '7px', 
            ...sparklineColors,
            background: 'rgba(0,0,0,0.2)',
            borderRadius: '8px',
            overflow: 'hidden',
            border: '1px solid rgba(148,163,184,0.05)',
            display: 'flex',
            alignItems: 'center',
            height: '50px'
        }
    }, [
        React.createElement('svg', { 
            key: 'svg',
            className: 'adtec-sparkline-svg', 
            viewBox: '0 -5 100 60', 
            preserveAspectRatio: 'none',
            style: { height: '50px', flex: 1 }
        }, [
            React.createElement('defs', { key: 'defs' }, [
                React.createElement('linearGradient', { 
                    key: 'grad',
                    id: "grad-final-" + id, 
                    x1: "0", y1: "50", x2: "0", y2: "0",
                    gradientUnits: "userSpaceOnUse"
                }, [
                    /* Colores en RGB puro para asegurar visibilidad absoluta */
                    React.createElement('stop', { key: 's1', offset: "0%", stopColor: "var(--grad-start, rgb(16, 185, 129))" }),
                    React.createElement('stop', { key: 's2', offset: "50%", stopColor: "var(--grad-mid, rgb(245, 158, 11))" }),
                    React.createElement('stop', { key: 's3', offset: "100%", stopColor: "var(--grad-end, rgb(239, 68, 68))" })
                ]),
                /* Fondo Degradado Tenue/Brilloso */
                React.createElement('linearGradient', { 
                    key: 'bg-grad',
                    id: "bg-grad-final-" + id, 
                    x1: "0", y1: "1", x2: "0", y2: "0"
                }, [
                    React.createElement('stop', { key: 'b1', offset: "0%", stopColor: "rgba(56, 189, 248, 0.02)" }),
                    React.createElement('stop', { key: 'b2', offset: "50%", stopColor: "rgba(56, 189, 248, 0.1)" }),
                    React.createElement('stop', { key: 'b3', offset: "100%", stopColor: "rgba(56, 189, 248, 0.02)" })
                ])
            ]),
            /* Fondo Degradado Tenue */
            React.createElement('rect', { 
                key: 'bg-rect',
                x: "0", y: "0", width: "100", height: "50", 
                fill: "url(#bg-grad-final-" + id + ")", 
                opacity: "0.6" 
            }),
            /* L√≠neas de Gu√≠a de Fondo */
            React.createElement('line', { key: 'g1', x1: "0", y1: "0", x2: "100", y2: "0", stroke: "rgba(255,255,255,0.05)", strokeWidth: "0.5" }),
            React.createElement('line', { key: 'g2', x1: "0", y1: "25", x2: "100", y2: "25", stroke: "rgba(255,255,255,0.05)", strokeWidth: "0.5", strokeDasharray: "2,2" }),
            React.createElement('line', { key: 'g3', x1: "0", y1: "50", x2: "100", y2: "50", stroke: "rgba(255,255,255,0.05)", strokeWidth: "0.5" }),
            React.createElement('path', {
                key: 'path',
                d: pathData,
                className: 'adtec-sparkline-path',
                stroke: strokeColor,
                fill: 'none',
                strokeWidth: '2',
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
            })
        ])
    ]);
});

const DashboardApp = () => {
    const [activeTabId, setActiveTabId] = useState((CONFIG.dashboard.tabs[0] && CONFIG.dashboard.tabs[0].id) || '0');
    const [lastData, setLastData] = useState({});
    const [alerts, setAlerts] = useState([]);
    const [controlState, setControlState] = useState({});
    const [pendingCommands, setPendingCommands] = useState({}); 
    const [historyData, setHistoryData] = useState([]); 
    const [liveData, setLiveData] = useState([]); 
    const [chartConfig, setChartConfig] = useState({
        ...CONFIG.chartConfig,
        filter: 'all',
        fromDate: '',
        toDate: '',
        timeRange: 'Ahora'
    });
    const [connStatus, setConnStatus] = useState('CONECTANDO...');
    const [connColor, setConnColor] = useState('#f59e0b');
    const [lastPacketTime, setLastPacketTime] = useState(0);
    const [lastArrivalLocal, setLastArrivalLocal] = useState(Date.now());
    const [currentDelta, setCurrentDelta] = useState(300000); // 5 min inicial (Aprendizaje)
    const [isLearning, setIsLearning] = useState(true);

    const BASE_URL = CONFIG.BASE_URL || "";
const normalizeFlat = (obj) => {
    if (!obj || typeof obj !== 'object') return { timestamp: new Date().toISOString() };

    const src = (obj.kv && typeof obj.kv === 'object') ? obj.kv : obj;

    const out = {};
    if (obj.timestamp) out.timestamp = obj.timestamp;

    for (const [k, v] of Object.entries(src || {})) {
        if (k === 'timestamp' || k === 'kv') continue;
        const kk = (typeof k === 'string' && k.startsWith('kv.')) ? k.slice(3) : k;
        out[kk] = v;
    }

    if (!out.timestamp) out.timestamp = new Date().toISOString();
    return out;
};


    // Memoria persistente para ubicaci√≥n (Latching)
    const [lastValidLocation, setLastValidLocation] = useState({ city: '--', coord: '--' });

    useEffect(() => {
        const currentLoc = getWidgetValueShared('gsm_location', lastData, CONFIG.dashboard.widgets);
        const currentCity = getWidgetValueShared('gsm_city_country', lastData, CONFIG.dashboard.widgets);
        
        if (currentLoc !== '--' && currentLoc !== '') {
            setLastValidLocation(prev => ({
                city: (currentCity !== '--' && currentCity !== '') ? currentCity : prev.city,
                coord: currentLoc
            }));
        }
    }, [lastData]);

    const getWidgetValue = (key) => getWidgetValueShared(key, lastData, CONFIG.dashboard.widgets);

    const currentTab = useMemo(() => 
        CONFIG.dashboard.tabs.find(t => String(t.id) === String(activeTabId)) || CONFIG.dashboard.tabs[0] || { width: 1000, height: 700 }
    , [activeTabId, CONFIG.dashboard.tabs]);

    useEffect(() => {
        if (!chartConfig.primaryY && CONFIG.dashboard.variables && CONFIG.dashboard.variables.length > 0) {
            setChartConfig(prev => ({ ...prev, primaryY: CONFIG.dashboard.variables[0].key }));
        }
    }, []);

    const fetchHistory = async () => {
        try {
// IMPORTANTE: aunque el chart est√© en "Ahora", igual pedimos 24h para seed de widgets/sparks
const rType = chartConfig.timeRange === 'Ahora' ? '24h' :
             chartConfig.timeRange === '24h' ? '24h' :
             chartConfig.timeRange === '7d' ? '7d' : 'rango';

            const url = new URL(BASE_URL + '/api/data', window.location.origin);
            url.searchParams.append("range_type", rType);
            if (rType === 'rango') {
                if (chartConfig.fromDate) url.searchParams.append("from_date", chartConfig.fromDate);
                if (chartConfig.toDate) url.searchParams.append("to_date", chartConfig.toDate);
            }

            const res = await fetch(url);
            if (res.ok) {
                const rawHistory = await res.json();

                // Normalizaci√≥n global sin "kv." (array de puntos flat)
                const history = Array.isArray(rawHistory) ? rawHistory.map(normalizeFlat) : [];
                setHistoryData(history);

                // Cargar historial en los Sparklines y Estad√≠sticas Diarias al inicio
                const todayStart = history.length > 0 ? (history[0].timestamp || null) : null;

                CONFIG.dashboard.widgets.forEach(w => {
                    if (w.showSparkline || w.type === 'gauge' || w.showMinMax) {
                        // Buffer visual: √∫ltimos 100 puntos (extraer desde row.kv)
                        const hDataBuffer = history.map(d => (d[w.key] ?? d['kv.' + w.key])).filter(v => v !== undefined && v !== null && v !== '--');

                        // Estad√≠sticas (Hoy): filtrar por fecha comparando con first timestamp (compat tolerante)
                        const hDataToday = (todayStart !== null)
                            ? history.filter(d => (d.timestamp || '') >= todayStart).map(d => (d[w.key] ?? d['kv.' + w.key])).filter(v => v !== undefined && v !== null && v !== '--')
                            : [];

                        // Pasar el historial completo en formato {timestamp, kv} al motor
                        try {
                            SparklineEngine.setHistory(w.id, w.key, history, w.min, w.max);
                        } catch (e) {
                            console.warn('SparklineEngine.setHistory fall√≥ para', w.id, e);
                        }
                    }
                });
            }
        } catch(e) { console.error("Error historial:", e); }
    };

    const fetchUpdate = async () => {
        try {
            const res = await fetch(BASE_URL + '/api/last');
            if (!res.ok) throw new Error("API Offline");
            
            const raw = await res.json();

            // Normalizaci√≥n global sin "kv." (flat keys)
const flat = normalizeFlat(raw);


            // Validar que la data es real
            const hasData = flat && flat.timestamp && flat.timestamp !== '--';

            if (hasData) {
                const hardwareTs = new Date(flat.timestamp).getTime();
                const isNewData = flat.timestamp !== (lastData && lastData.timestamp);

                if (isNewData) {
                    // --- NUEVA TELEMETR√çA DETECTADA ---
                    if (lastPacketTime > 0) {
                        const rawDelta = Math.abs(hardwareTs - lastPacketTime);
                        // Media M√≥vil para suavizar Jitter y Techo de 10 min
                        const newDelta = Math.min(600000, (currentDelta * 0.6) + (rawDelta * 0.4));
                        setCurrentDelta(newDelta);
                        setIsLearning(false);
                    }
                    
                    setLastPacketTime(hardwareTs);
                    setLastArrivalLocal(Date.now());
                    // Mantener flat para compat visual dentro del template
                    setLastData(flat);

                    // Sincronizaci√≥n de Estado Deseado
                    setPendingCommands(prev => {
                        const next = { ...prev };
                        let changed = false;
                        Object.keys(next).forEach(key => {
                            const realVal = flat[key];
                            const desiredVal = next[key].value;
                            const isMatch = (String(realVal) === String(desiredVal)) || 
                                          (realVal === 1 && desiredVal === true) || 
                                          (realVal === 0 && desiredVal === false) ||
                                          (realVal === "ON" && desiredVal === true) ||
                                          (realVal === "OFF" && desiredVal === false);
                            if (isMatch || (Date.now() - next[key].ts > 30000)) {
                                delete next[key];
                                changed = true;
                            }
                        });
                        return changed ? next : prev;
                    });

                    // Actualizaci√≥n Centralizada del Motor (usar valores ya normalizados)
                    CONFIG.dashboard.widgets.forEach(w => {
                        const rawVal = flat[w.key] ?? flat['kv.' + w.key];
                        SparklineEngine.update(w.id, w.key, rawVal, w.min || 0, w.max || 100, flat.timestamp);
                    });

                    // Estado reportado por el hardware
                    const connWidget = CONFIG.dashboard.widgets.find(w => w.type === 'connection');
                    const statusKey = connWidget?.statusKey || 'gsm_stored_state';
                    const reportedState = String(flat[statusKey] ?? "ONLINE").toUpperCase();

                    
                    if (reportedState === "ONLINE" || reportedState === "REG_OK") {
                        setConnStatus("SISTEMA ONLINE");
                        setConnColor("#10b981");
                    } else if (reportedState === "BUSCANDO") {
                        setConnStatus("BUSCANDO RED...");
                        setConnColor("#f59e0b");
                    } else if (reportedState === "OFFLINE") {
                        setConnStatus("ERROR: SIN CHIP");
                        setConnColor("#ef4444");
                    } else {
                        setConnStatus(reportedState);
                        setConnColor("#10b981");
                    }

                    if (chartConfig.timeRange === 'Ahora') {
                        setLiveData(prev => {
                            const next = [...prev, flat];
                            return next.length > 200 ? next.slice(-200) : next;
                        });
                    }
                } else {
                    // --- NO HAY DATOS NUEVOS, EVALUAR TIEMPO ---
                    const elapsed = Date.now() - lastArrivalLocal;
                    // Margen din√°mico: Delta + 2s (o 10s si estamos aprendiendo)
                    const threshold = currentDelta + (isLearning ? 10000 : 2000);

                    if (elapsed > (threshold * 2)) {
                        setConnStatus("EQUIPO OFFLINE");
                        setConnColor("#ef4444"); // Rojo
                    } else if (elapsed > threshold) {
                        setConnStatus("CONECTANDO...");
                        setConnColor("#f59e0b"); // Naranja
                    }
                }
            } else {
                setConnStatus("SIN DATOS");
                setConnColor("#ef4444"); // Rojo
            }
        } catch(e) {
            setConnStatus("API OFFLINE");
            setConnColor("#ef4444");
            console.error("Error actualizaci√≥n:", e);
        }

        try {
            const res = await fetch(BASE_URL + '/api/control_state');
            if (res.ok) {
                setControlState(await res.json());
            }
        } catch(e) { console.warn("Fallo Controles:", e); }

        try {
            const resA = await fetch(BASE_URL + '/api/alerts');
            if (resA.ok) {
                setAlerts(await resA.json());
            }
        } catch(e) { console.warn("Fallo Alertas:", e); }
    };

    const displayData = useMemo(() => {
        const isLive = chartConfig.timeRange === 'Ahora';
        let filtered = isLive ? liveData : historyData;
        const now = new Date().getTime();

        if (!isLive) {
            // 1. Filtro de Tiempo (Rango R√°pido)
            if (chartConfig.timeRange === '24h') {
                const oneDayAgo = now - (24 * 60 * 60 * 1000);
                filtered = historyData.filter(d => new Date(d.timestamp).getTime() >= oneDayAgo);
            } else if (chartConfig.timeRange === '7d') {
                const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);
                filtered = historyData.filter(d => new Date(d.timestamp).getTime() >= sevenDaysAgo);
            } else if (chartConfig.timeRange === 'Rango') {
                if (chartConfig.fromDate && chartConfig.toDate) {
                    const start = new Date(chartConfig.fromDate).getTime();
                    const end = new Date(chartConfig.toDate).getTime();
                    filtered = historyData.filter(d => {
                        const ts = new Date(d.timestamp).getTime();
                        return ts >= start && ts <= end;
                    });
                }
            }

            // 2. Filtro Horario (D√≠a / Noche)
            if (chartConfig.filter === 'day') {
                filtered = filtered.filter(d => {
                    const h = new Date(d.timestamp).getHours();
                    return h >= 7 && h < 19;
                });
            } else if (chartConfig.filter === 'night') {
                filtered = filtered.filter(d => {
                    const h = new Date(d.timestamp).getHours();
                    return h < 7 || h >= 19;
                });
            }
        }

        const finalData = Array.isArray(filtered) ? filtered : [];
        return finalData.map(d => {
            if (!d) return { t: '', v: null, v2: null, fullTimestamp: null };
            const ts = new Date(d.timestamp);
            const label = isLive 
                ? ts.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
                : ts.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' }) + ' ' + ts.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            
            const v1Raw = parseFloat((d[chartConfig.primaryY] ?? (d.kv ? d.kv[chartConfig.primaryY] : d['kv.' + chartConfig.primaryY])));
            const v2Raw = chartConfig.secondaryY ? parseFloat((d[chartConfig.secondaryY] ?? (d.kv ? d.kv[chartConfig.secondaryY] : d['kv.' + chartConfig.secondaryY]))) : NaN;

            // BLINDAJE PUNTO 4: Chart.js tratar√° null como un hueco en la l√≠nea
            const v1 = v1Raw === -50.0 ? null : v1Raw;
            const v2 = v2Raw === -50.0 ? null : v2Raw;

            return {
                t: label,
                v: v1,
                v2: v2,
                fullTimestamp: d.timestamp
            };
        }); // No filtramos, para permitir huecos (null) en Chart.js
    }, [chartConfig, historyData, liveData]);

    const sendControl = async (key, val) => {
        try {
            // Marcar como pendiente de inmediato
            setPendingCommands(prev => ({ 
                ...prev, 
                [key]: { value: val, ts: Date.now() } 
            }));

            const res = await fetch(BASE_URL + '/api/control_state', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ [key]: val })
            });
            if (res.ok) {
                setControlState(prev => ({ ...prev, [key]: val }));
            }
        } catch(e) { console.error("Error env√≠o control:", e); }
    };

    useEffect(() => {
        let mounted = true;
        let intervalId = null;

        const startLoop = async () => {
            try {
                // Asegurarnos de cargar historial antes de hacer la primera actualizaci√≥n live
                await fetchHistory();
            } catch (e) {
                console.warn('fetchHistory fall√≥ en arranque', e);
            }
            if (!mounted) return;

            try {
                await fetchUpdate();
            } catch (e) {
                console.warn('fetchUpdate inicial fall√≥', e);
            }

            intervalId = setInterval(fetchUpdate, CONFIG.refreshInterval);
        };

        startLoop();

        return () => {
            mounted = false;
            if (intervalId) clearInterval(intervalId);
        };
    }, [chartConfig.primaryY, chartConfig.secondaryY, chartConfig.timeRange, chartConfig.fromDate, chartConfig.toDate]);

    useEffect(() => {
        setTimeout(() => { if(window.lucide) lucide.createIcons(); }, 100);
    }, [activeTabId]);

    const activeVarLabel = useMemo(() => {
        return CONFIG.labels[chartConfig.primaryY] || chartConfig.primaryY;
    }, [chartConfig.primaryY]);

    return (
        <div className="adtec-dashboard-root">
            <div className="tabs-nav">
                {CONFIG.dashboard.tabs.map(t => (
                    <div 
                        key={t.id} 
                        className={"tab-btn " + (activeTabId === t.id ? "active" : "")} 
                        onClick={() => setActiveTabId(t.id)}
                        style={{ position: 'relative' }}
                    >
                        {t.icon && t.icon.length > 2 ? (
                            <i data-lucide={t.icon}></i>
                        ) : (
                            <span>{t.icon || 'üìÑ'}</span>
                        )} {t.name}
                        {t.type === 'alerts' && alerts.length > 0 && (
                            <span className="alert-badge">{alerts.length}</span>
                        )}
                    </div>
                ))}
            </div>

            <div className="adtec-card" style={{ width: currentTab.width + 'px', minHeight: currentTab.height + 'px', margin: '0 auto' }}>
                {currentTab.type !== 'charts' && (
                    <div className="card-header">
                        <div className="logo-section">
                            <div className="logo-icon"><div className="logo-icon-inner">ADTEC</div></div>
                            <span className="card-title">{currentTab.title}</span>
                        </div>
                        {currentTab.type === 'control' && (
                            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', background: 'rgba(255,255,255,0.05)', padding: '5px 12px', borderRadius: '20px', border: '1px solid rgba(148,163,184,0.1)' }}>
                                <span style={{ fontSize: '9px', fontWeight: 700, color: controlState.manual ? 'var(--adtec-accent)' : '#9ca3af' }}>
                                    {controlState.manual ? 'MANUAL' : 'AUTO'}
                                </span>
                                <label className="switch" style={{ transform: 'scale(0.7)' }}>
                                    <input type="checkbox" checked={!!controlState.manual} onChange={(e) => sendControl('manual', e.target.checked)} />
                                    <span className="slider"></span>
                                </label>
                            </div>
                        )}
                        <div style={{ fontSize: '11px', fontWeight: '800', color: connColor }}>{connStatus}</div>
                    </div>
                )}

                <div className={currentTab.type === 'charts' ? "card-body-flat" : "card-body"}>
                    {currentTab.type !== 'charts' && <div className="grid-bg"></div>}
                    
                    {currentTab.type === 'alerts' ? (
                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: '25px', overflowY: 'auto' }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '25px', borderBottom: '1px solid rgba(148, 163, 184, 0.1)', paddingBottom: '15px' }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                    <div className="logo-icon" style={{ width: 30, height: 30, borderRadius: 8, background: '#ef4444', boxShadow: '0 0 15px rgba(239, 68, 68, 0.4)' }}>
                                        <div className="logo-icon-inner" style={{ fontSize: 9 }}>ADTEC</div>
                                    </div>
                                    <h2 style={{ margin: 0, fontSize: '18px', color: '#f8fafc' }}>Centro de Notificaciones</h2>
                                </div>
                                <button 
                                    onClick={async () => {
                                        if (confirm('¬øLimpiar todo el historial de alertas?')) {
                                            await fetch(BASE_URL + '/api/alerts/clear', { method: 'POST' });
                                            setAlerts([]);
                                        }
                                    }}
                                    style={{ padding: '6px 15px', background: 'rgba(239, 68, 68, 0.1)', border: '1px solid #ef4444', borderRadius: '6px', color: '#ef4444', cursor: 'pointer', fontWeight: 'bold', fontSize: '11px' }}
                                >
                                    LIMPIAR HISTORIAL
                                </button>
                            </div>

                            {alerts.length === 0 ? (
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', opacity: 0.5 }}>
                                    <span style={{ fontSize: '48px', marginBottom: '15px' }}>üü¢</span>
                                    <p style={{ fontSize: '14px', fontWeight: '600' }}>Sistema en estado √≥ptimo</p>
                                    <p style={{ fontSize: '12px' }}>No hay alertas registradas en este momento.</p>
                                </div>
                            ) : (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                                    {[...alerts].reverse().map((a, i) => (
                                        <div key={i} className="alert-card-item">
                                            <div className="alert-card-side"></div>
                                            <div className="alert-card-content">
                                                <div className="alert-card-header">
                                                    <span className="alert-card-tag">CR√çTICO</span>
                                                    <span className="alert-card-time">{new Date(a.timestamp).toLocaleString('es-ES')}</span>
                                                </div>
                                                <div className="alert-card-msg">{a.msg}</div>
                                                <div className="alert-card-detail">
                                                    Valor: <span style={{ color: '#ef4444', fontWeight: 'bold' }}>{formatValue(a.valor || a.value, 'fixed1', "")}</span>
                                                    {(a.referencia !== undefined && a.referencia !== 0) && (
                                                        <> | Ref: <span style={{ color: '#9ca3af' }}>{formatValue(a.referencia || a.ref, 'fixed1', "")}</span></>
                                                    )}
                                                    {a.signal && <> | Se√±al: <span style={{ color: 'var(--adtec-accent)' }}>{a.signal}</span></>}
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    ) : currentTab.type === 'charts' ? (
                        <div style={{ flex: 1, position: 'relative', overflowY: 'auto', padding: 25, display: 'flex', flexDirection: 'column' }}>
                            {(!CONFIG.dashboard.variables || CONFIG.dashboard.variables.length === 0) ? (
                                <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', opacity: 0.5 }}>
                                    <p>No hay variables disponibles para graficar.</p>
                                </div>
                            ) : (
                                <>
                                    <div style={{ borderBottom: '1px solid rgba(148, 163, 184, 0.2)', paddingBottom: 15, marginBottom: 20, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                                    <div className="logo-icon" style={{ width: 30, height: 30, borderRadius: 8, boxShadow: '0 0 15px rgba(250, 204, 21, 0.4)' }}>
                                        <div className="logo-icon-inner" style={{ fontSize: 9 }}>ADTEC</div>
                                    </div>
                                    <h2 style={{ margin: 0, fontSize: 18, color: '#f8fafc', letterSpacing: '0.05em' }}>{currentTab.title}</h2>
                                    <div style={{ marginLeft: 10, padding: '2px 8px', background: '#ef4444', color: 'white', fontSize: 9, borderRadius: 4, fontWeight: 800, display: 'flex', alignItems: 'center', gap: 5 }}>
                                        <span style={{ width: 4, height: 4, background: 'white', borderRadius: '50%', display: 'inline-block' }}></span> LIVE
                                    </div>
                                </div>
                                <div style={{ display: 'flex', gap: 8 }}>
                                    <button 
                                        onClick={() => setChartConfig(prev => ({
                                            ...prev,
                                            primaryY: (CONFIG.dashboard.variables && CONFIG.dashboard.variables[0]?.key) || '',
                                            secondaryY: '',
                                            filter: 'all',
                                            fromDate: '',
                                            toDate: '',
                                            timeRange: 'Ahora'
                                        }))}
                                        style={{ padding: '5px 10px', borderRadius: 6, background: 'rgba(255,255,255,0.05)', color: '#9ca3af', border: '1px solid rgba(148,163,184,0.1)', cursor: 'pointer', fontSize: 10 }}
                                    >Reset filtros</button>
                                    <a href={BASE_URL + "/api/download/xlsx?channel=ingreso"} style={{ padding: '5px 10px', borderRadius: 6, background: 'var(--adtec-accent)', color: 'black', border: 'none', cursor: 'pointer', fontWeight: 700, fontSize: 10, textDecoration: 'none' }}>XLSX</a>
                                </div>
                            </div>

                            <div style={{ background: 'rgba(255,255,255,0.03)', padding: 15, borderRadius: 12, border: '1px solid rgba(148, 163, 184, 0.1)', marginBottom: 20 }}>
                                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 15, marginBottom: 15 }}>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#38bdf8', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 800 }}>Eje Y Principal</label>
                                        <select 
                                            value={chartConfig.primaryY} 
                                            onChange={(e) => setChartConfig(prev => ({ ...prev, primaryY: e.target.value }))}
                                            style={{ width: '100%', padding: '8px', background: '#1e293b', color: '#38bdf8', border: '1px solid rgba(56, 189, 248, 0.4)', borderRadius: 6, fontSize: 12, fontWeight: 'bold', boxShadow: '0 0 10px rgba(56, 189, 248, 0.1)' }}
                                        >
                                            {(CONFIG.dashboard.variables || []).map(v => <option key={v.key} value={v.key} style={{ color: 'white' }}>{v.label}</option>)}
                                        </select>
                                    </div>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#a855f7', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 800 }}>Eje Y Secundario</label>
                                        <select 
                                            value={chartConfig.secondaryY} 
                                            onChange={(e) => setChartConfig(prev => ({ ...prev, secondaryY: e.target.value }))}
                                            style={{ width: '100%', padding: '8px', background: '#1e293b', color: '#a855f7', border: '1px solid rgba(168, 85, 247, 0.4)', borderRadius: 6, fontSize: 12, fontWeight: 'bold', boxShadow: '0 0 10px rgba(168, 85, 247, 0.1)' }}
                                        >
                                            <option value="" style={{ color: 'white' }}>(sin eje secundario)</option>
                                            {(CONFIG.dashboard.variables || []).map(v => <option key={v.key} value={v.key} style={{ color: 'white' }}>{v.label}</option>)}
                                        </select>
                                    </div>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#9ca3af', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 600 }}>Vista Horaria</label>
                                        <div style={{ display: 'flex', gap: 5 }}>
                                            {[
                                                { id: 'all', label: 'Todo', icon: 'üåì' },
                                                { id: 'day', label: 'D√≠a', icon: '‚òÄÔ∏è' },
                                                { id: 'night', label: 'Noche', icon: 'üåô' }
                                            ].map(f => (
                                                <button
                                                    key={f.id}
                                                    disabled={chartConfig.timeRange === 'Ahora'}
                                                    onClick={() => setChartConfig(prev => ({ ...prev, filter: f.id }))}
                                                    style={{ 
                                                        flex: 1,
                                                        padding: '8px', 
                                                        borderRadius: 6, 
                                                        border: "1px solid " + (chartConfig.filter === f.id ? 'var(--adtec-accent)' : 'rgba(148,163,184,0.1)'),
                                                        background: chartConfig.filter === f.id ? 'rgba(56,189,248,0.1)' : '#1e293b',
                                                        color: chartConfig.filter === f.id ? 'var(--adtec-accent)' : '#9ca3af',
                                                        fontSize: 11,
                                                        cursor: 'pointer',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        gap: 4,
                                                        opacity: chartConfig.timeRange === 'Ahora' ? 0.5 : 1
                                                    }}
                                                >
                                                    {f.icon} {f.label}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>

                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1.5fr', gap: 15 }}>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#9ca3af', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 600 }}>Desde</label>
                                        <input 
                                            type="datetime-local" 
                                            disabled={chartConfig.timeRange !== 'Rango'}
                                            value={chartConfig.fromDate || ''}
                                            onChange={(e) => setChartConfig(prev => ({ ...prev, fromDate: e.target.value }))}
                                            style={{ width: '100%', padding: '8px', background: '#1e293b', color: 'white', border: '1px solid rgba(148, 163, 184, 0.2)', borderRadius: 6, fontSize: 11, opacity: chartConfig.timeRange !== 'Rango' ? 0.5 : 1 }}
                                        />
                                    </div>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#9ca3af', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 600 }}>Hasta</label>
                                        <input 
                                            type="datetime-local" 
                                            disabled={chartConfig.timeRange !== 'Rango'}
                                            value={chartConfig.toDate || ''}
                                            onChange={(e) => setChartConfig(prev => ({ ...prev, toDate: e.target.value }))}
                                            style={{ width: '100%', padding: '8px', background: '#1e293b', color: 'white', border: '1px solid rgba(148, 163, 184, 0.2)', borderRadius: 6, fontSize: 11, opacity: chartConfig.timeRange !== 'Rango' ? 0.5 : 1 }}
                                        />
                                    </div>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#9ca3af', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 600 }}>Rango R√°pido</label>
                                        <div style={{ display: 'flex', gap: 5 }}>
                                            {[
                                                { id: 'Ahora', label: 'LIVE', icon: 'üì°' },
                                                { id: '24h', label: '24H', icon: 'üìÖ' },
                                                { id: '7d', label: '7D', icon: 'üóìÔ∏è' },
                                                { id: 'Rango', label: 'RANGO', icon: '‚ôæÔ∏è' }
                                            ].map(r => (
                                                <button
                                                    key={r.id}
                                                    onClick={() => setChartConfig(prev => ({ ...prev, timeRange: r.id }))}
                                                    style={{ 
                                                        flex: 1,
                                                        padding: '8px 4px', 
                                                        borderRadius: 6, 
                                                        border: "1px solid " + (chartConfig.timeRange === r.id ? 'var(--adtec-accent)' : 'rgba(148,163,184,0.1)'),
                                                        background: chartConfig.timeRange === r.id ? 'rgba(56,189,248,0.1)' : '#1e293b',
                                                        color: chartConfig.timeRange === r.id ? 'var(--adtec-accent)' : '#9ca3af',
                                                        fontSize: 10,
                                                        fontWeight: 700,
                                                        cursor: 'pointer'
                                                    }}
                                                >
                                                    {r.icon} {r.label}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div style={{ height: '400px', background: 'rgba(0,0,0,0.2)', borderRadius: 12, padding: 15 }}>
                                <DashboardChart 
                                    widget={{ label: activeVarLabel }} 
                                    dataHistory={displayData} 
                                    chartConfig={chartConfig}
                                />
                            </div>
                                </>
                            )}
                        </div>
                    ) : (
                        <div className="widgets-area">
                            {CONFIG.dashboard.widgets.filter(w => String(w.tabId) === String(activeTabId)).map(w => {
                            const valStr = getWidgetValue(w.key);
                            const val = parseFloat(valStr);
                            const style = { left: w.x, top: w.y, width: w.w, height: w.h, position: 'absolute' };

                            if (w.type === 'label') {
                                return (
                                    <div key={w.id} className="adtec-label-widget" style={{ ...style, color: w.color || 'white', fontSize: w.fontSize || 14, fontWeight: 'bold' }}>
                                        {w.label}
                                    </div>
                                );
                            }

                            if (w.type === 'chart' || w.type === 'summary-chart') {
                                return (
                                    <div key={w.id} className="adtec-status-item" style={style}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 5, gap: 8 }}>
                                            <h3 style={{ flex: 1, wordBreak: 'break-word', lineHeight: '1.1' }}>{w.label}</h3>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, flexShrink: 0 }}>
                                                {!w.hideKey && <span style={{ fontSize: '9px', opacity: 0.4, color: '#9ca3af' }}>{w.key}</span>}
                                                <a href={BASE_URL + "/api/download/xlsx?channel=ingreso"} title="Descargar XLSX" style={{ color: '#94a3b8', textDecoration: 'none' }}>
                                                    <i data-lucide="download" style={{ width: 14, height: 14 }}></i>
                                                </a>
                                                <span style={{ fontSize: '14px', fontWeight: '800', color: 'var(--adtec-accent)' }}>{valStr}</span>
                                            </div>
                                        </div>
                                        <div style={{ flex: 1, position: 'relative', minHeight: 0 }}>
                                            <DashboardChart widget={w} dataHistory={
                                                historyData && historyData.length > 0 ? historyData.map(d => {
                                                    const ts = new Date(d.timestamp);
                                                    const label = ts.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' }) + ' ' + ts.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
                                                    const raw = (d[w.key] ?? (d.kv ? d.kv[w.key] : d['kv.' + w.key]));
                                                    const parsed = parseFloat(raw);
                                                    const v = isNaN(parsed) ? null : (parsed === -50.0 ? null : parsed);
                                                    return { t: label, v: v, v2: null, fullTimestamp: d.timestamp };
                                                }) : []
                                            } chartConfig={{ primaryY: w.key }} />
                                        </div>
                                    </div>
                                );
                            }

                            return (
                                <div key={w.id} className="adtec-status-item" style={style}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 8 }}>
                                            <h3 style={{ flex: 1, wordBreak: 'break-word', lineHeight: '1.1' }}>{w.label}</h3>
                                        {!w.hideKey && <span style={{ fontSize: '9px', opacity: 0.4, color: '#9ca3af', flexShrink: 0 }}>{w.key}</span>}
                                    </div>

                                    {w.type === 'gauge' && (() => {
                                        const numVal = isNaN(parseFloat(valStr)) ? (w.min || 0) : parseFloat(valStr);
                                        const min = w.min || 0;
                                        const max = w.max || 100;
                                        const pct = Math.max(0, Math.min(100, ((numVal - min) / (Math.max(1, max - min))) * 100));
                                        
                                        // M√≠n/M√°x reales del d√≠a desde el motor
                                        const stats = SparklineEngine.getStats(w.id);
                                        const minDay = stats.min !== undefined ? formatValue(stats.min, w.format, "") : "--";
                                        const maxDay = stats.max !== undefined ? formatValue(stats.max, w.format, "") : "--";

                                        return (
                                            <>
                                                <div className="adtec-status-value" style={{ textAlign: 'center' }}>
                                                    {valStr.replace(w.unit || '', '')} 
                                                    <span style={{ fontSize: '12px', fontWeight: 400, opacity: 0.6 }}>{w.unit}</span>
                                                </div>

                                                {w.showMinMax && (
                                                    <div style={{ fontSize: '10px', color: '#94a3b8', textAlign: 'center', marginTop: '-2px', marginBottom: '10px', fontWeight: 500 }}>
                                                        M√≠n: {minDay} {w.unit} ¬∑ M√°x: {maxDay} {w.unit}
                                                    </div>
                                                )}

                                            {(w.showBar ?? true) && (
                                                <div className="adtec-temp-bar" style={{ background: getGradientByType('TEMP', 0.25, w.inverted), marginTop: w.showMinMax ? '0px' : '5px' }}>
                                                    <div 
                                                        className="adtec-temp-bar-fill" 
                                                        style={{ 
                                                            width: pct + "%",
                                                            background: getGradientByType('TEMP', 1, w.inverted),
                                                            backgroundSize: (100 / (Math.max(1, pct) / 100)) + "% 100%",
                                                            boxShadow: "0 0 10px " + getGaugeColor(numVal, w.key) + "66"
                                                        }} 
                                                    />
                                                </div>
                                            )}

                                            {w.showSparkline && (
                                                <Sparkline 
                                                    id={w.id} 
                                                    variableKey={w.key} 
                                                    min={w.min} 
                                                    max={w.max} 
                                                    inverted={w.inverted} 
                                                    // Evitar que el fallback numVal ensucie el gr√°fico al inicio
                                                    value={valStr === '--' ? undefined : numVal} 
                                                    showShadow={w.sparklineShadow}
                                                    historyTick={historyData.length}
                                                />
                                            )}
                                        </>
                                    );
                                    })()}

                                    {w.type === 'indicator' && (() => {
                                        const isOn = valStr === 'ON' || valStr === 'ACTIVO' || valStr === 'TRUE';
                                        return (
                                            <div className={"adtec-status-chip " + (isOn ? "on" : "off")} style={{ marginTop: 'auto', alignSelf: 'flex-start' }}>
                                                <span className={"adtec-status-dot " + (isOn ? "on" : "off")} />
                                                <span>{isOn ? 'ACTIVO' : 'INACTIVO'}</span>
                                            </div>
                                        );
                                    })()}

                                    {w.type === 'control-relay' && (() => {
                                        const isOn = valStr === 'ON' || valStr === 'ACTIVO' || valStr === 'TRUE';
                                        const isManual = !!controlState.manual;
                                        const pending = pendingCommands[w.target];
                                        const isPending = pending !== undefined;

                                        return (
                                            <>
                                                <div className={"adtec-status-chip " + (isOn ? "on" : "off")} style={{ marginBottom: 10, alignSelf: 'flex-start' }}>
                                                    <span className={"adtec-status-dot " + (isOn ? "on" : "off")} />
                                                    <span>{isOn ? 'ACTIVO' : 'INACTIVO'}</span>
                                                </div>
                                                <div style={{ display: 'flex', gap: '5px' }}>
                                                    <button 
                                                        className="vfd-btn start" 
                                                        disabled={!isManual} 
                                                        style={{ 
                                                            background: isOn ? '#10b981' : (pending?.value === true ? '#065f46' : undefined),
                                                            opacity: isManual ? 1 : 0.5,
                                                            cursor: isManual ? 'pointer' : 'not-allowed',
                                                            boxShadow: pending?.value === true ? '0 0 10px rgba(16, 185, 129, 0.4)' : 'none'
                                                        }} 
                                                        onClick={() => sendControl(w.target, true)}
                                                    >
                                                        {pending?.value === true ? '‚è≥ ON...' : 'ON'}
                                                    </button>
                                                    <button 
                                                        className="vfd-btn stop" 
                                                        disabled={!isManual} 
                                                        style={{ 
                                                            background: !isOn ? '#ef4444' : (pending?.value === false ? '#7f1d1d' : undefined),
                                                            opacity: isManual ? 1 : 0.5,
                                                            cursor: isManual ? 'pointer' : 'not-allowed',
                                                            boxShadow: pending?.value === false ? '0 0 10px rgba(239, 68, 68, 0.4)' : 'none'
                                                        }} 
                                                        onClick={() => sendControl(w.target, false)}
                                                    >
                                                        {pending?.value === false ? '‚è≥ OFF...' : 'OFF'}
                                                    </button>
                                                </div>
                                            </>
                                        );
                                    })()}

                                    {w.type === 'control-vfd' && (() => {
                                        const freq = parseFloat(controlState[w.target] || 0);
                                        const isOn = valStr === 'ON' || valStr === 'ACTIVO' || valStr === 'TRUE';
                                        const isManual = !!controlState.manual;
                                        const pending = pendingCommands[w.target + '_state'];

                                        return (
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: 15, marginTop: 5, alignItems: 'center', width: '100%' }}>
                                                <div className={"vfd-dial " + (isOn ? "on" : "")}>
                                                    <div className="vfd-dial-value">{freq.toFixed(1)}</div>
                                                    <div className="vfd-dial-unit">Hz</div>
                                                </div>
                                                <input 
                                                    type="range" min="0" max="60" step="0.5" 
                                                    value={freq}
                                                    disabled={!isManual}
                                                    style={{ width: '100%', accentColor: 'var(--adtec-accent)', opacity: isManual ? 1 : 0.5 }}
                                                    onChange={(e) => sendControl(w.target, parseFloat(e.target.value))}
                                                />
                                                <div style={{ display: 'flex', gap: '5px', width: '100%' }}>
                                                    <button 
                                                        className="vfd-btn start" 
                                                        disabled={!isManual} 
                                                        style={{ 
                                                            background: isOn ? '#10b981' : (pending?.value === true ? '#065f46' : undefined),
                                                            opacity: isManual ? 1 : 0.5,
                                                            cursor: isManual ? 'pointer' : 'not-allowed',
                                                            boxShadow: pending?.value === true ? '0 0 10px rgba(16, 185, 129, 0.4)' : 'none'
                                                        }} 
                                                        onClick={() => sendControl(w.target + '_state', true)}
                                                    >
                                                        {pending?.value === true ? '‚è≥ RUN...' : 'RUN'}
                                                    </button>
                                                    <button 
                                                        className="vfd-btn stop" 
                                                        disabled={!isManual} 
                                                        style={{ 
                                                            background: !isOn ? '#ef4444' : (pending?.value === false ? '#7f1d1d' : undefined),
                                                            opacity: isManual ? 1 : 0.5,
                                                            cursor: isManual ? 'pointer' : 'not-allowed',
                                                            boxShadow: pending?.value === false ? '0 0 10px rgba(239, 68, 68, 0.4)' : 'none'
                                                        }} 
                                                        onClick={() => sendControl(w.target + '_state', false)}
                                                    >
                                                        {pending?.value === false ? '‚è≥ STOP...' : 'STOP'}
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    })()}

                                    {w.type === 'connection' && (() => {
                                        const sigKey = w.signalKey || w.key;
                                        const sigVal = parseFloat(getWidgetValue(sigKey) || getWidgetValue('gsm_signal') || "0");
                                        const isSystemOnline = connStatus.includes("ONLINE") || connStatus.includes("CONECTANDO");
                                        
                                        return (
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '5px' }}>
                                                <div style={{ display: 'flex', gap: '2px', alignItems: 'flex-end', height: '20px' }}>
                                                    {[1, 2, 3, 4, 5].map(i => {
                                                        const threshold = i * 6; // Rango 0-31 CSQ (aprox 6 por barra)
                                                        const isBarActive = isSystemOnline && sigVal >= threshold;
                                                        return React.createElement('div', {
                                                            key: i,
                                                            style: {
                                                                width: '3px',
                                                                height: (i * 4) + 'px',
                                                                background: isBarActive ? 'var(--adtec-accent)' : 'rgba(255,255,255,0.1)',
                                                                borderRadius: '1px',
                                                                boxShadow: isBarActive ? '0 0 5px var(--adtec-accent)' : 'none'
                                                            }
                                                        });
                                                    })}
                                                </div>
                                                <div className="adtec-status-chip" style={{ margin: 0, background: connColor + '22', border: '1px solid ' + connColor + '44', color: connColor }}>
                                                    <span className="adtec-status-dot" style={{ background: connColor, boxShadow: '0 0 8px ' + connColor }} />
                                                    <span style={{ fontWeight: 800, fontSize: '10px' }}>{connStatus}</span>
                                                </div>
                                            </div>
                                        );
                                    })()}

                                    {w.type === 'datetime' && (() => {
                                        const rawVal = getWidgetValue(w.key);
                                        const formatted = formatValue(rawVal === '--' ? new Date().toISOString() : rawVal, w.format || 'datetime_full', w.unit);
                                        const parts = formatted.split('|');
                                        const displayTime = parts[0];
                                        const displayDate = parts[1] || '';
                                        
                                        return (
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '5px' }}>
                                                <span style={{ fontSize: '20px' }}>‚è∞</span>
                                                <div>
                                                    <div style={{ fontSize: '14px', color: 'var(--adtec-accent)', fontWeight: 800 }}>{displayTime}</div>
                                                    {displayDate && <div style={{ fontSize: '10px', color: '#9ca3af' }}>{displayDate}</div>}
                                                </div>
                                            </div>
                                        );
                                    })()}

                                    {w.type === 'text' && (() => {
                                        if (w.label.toLowerCase().includes('red') || w.label.toLowerCase().includes('estado')) {
                                            return (
                                                <div className="adtec-status-chip" style={{ marginTop: 'auto', alignSelf: 'flex-start', background: connColor + '22', border: '1px solid ' + connColor + '44', color: connColor }}>
                                                    <span className="adtec-status-dot" style={{ background: connColor, boxShadow: '0 0 8px ' + connColor }} />
                                                    <span style={{ fontWeight: 800, fontSize: '10px' }}>{connStatus}</span>
                                                </div>
                                            );
                                        }

                                        // M√≠n/M√°x reales del d√≠a desde el motor (Unificado)
                                        const stats = SparklineEngine.getStats(w.id);
                                        const minDay = stats.min !== undefined ? formatValue(stats.min, w.format, "") : "--";
                                        const maxDay = stats.max !== undefined ? formatValue(stats.max, w.format, "") : "--";

                                        return (
                                            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%' }}>
                                                <div className="adtec-status-value" style={{ textAlign: 'center' }}>
                                                    {valStr.replace(w.unit || '', '')} 
                                                    <span style={{ fontSize: '12px', fontWeight: 400, opacity: 0.6 }}>{w.unit}</span>
                                                </div>
                                                {w.showMinMax && (
                                                    <div style={{ fontSize: '10px', color: '#94a3b8', textAlign: 'center', marginTop: '-2px', fontWeight: 500 }}>
                                                        M√≠n: {minDay} {w.unit} ¬∑ M√°x: {maxDay} {w.unit}
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })()}

                                    {w.type === 'location' && (() => {
                                        const displayCity = lastValidLocation.city !== '--' ? lastValidLocation.city : 'Ubicaci√≥n Pro';
                                        const displayCoords = lastValidLocation.coord !== '--' ? lastValidLocation.coord : 'Detectando GPS...';
                                        return (
                                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 5, color: '#9ca3af' }}>
                                                <span style={{ fontSize: 20 }}>üìç</span>
                                                <div>
                                                    <div style={{ fontSize: 12, color: 'white', fontWeight: 600 }}>{displayCity}</div>
                                                    <div style={{ fontSize: 10, opacity: 0.6 }}>{displayCoords}</div>
                                                </div>
                                            </div>
                                        );
                                    })()}
                                </div>
                            );
                        })}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

ReactDOM.render(<DashboardApp />, document.getElementById('dashboard-root'));

            
            // Inicializar iconos despu√©s de que React termine
            setTimeout(() => { if(window.lucide) lucide.createIcons(); }, 500);
            
            console.log("‚úÖ ADTEC Dashboard: Renderizado exitoso.");
        } catch (err) {
            console.error("‚ùå Error Cr√≠tico Dashboard:", err);
            document.getElementById('error-fallback').style.display = 'block';
            document.getElementById('error-details').innerText = err.stack || err.message;
        }
    </script>
</body>
</html>
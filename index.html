<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADTEC ¬∑ Invernadero Pro Dashboard</title>
    
    <!-- Scripts Profesionales (Locales) -->
    <script src="libs/react.production.min.js"></script>
    <script src="libs/react-dom.production.min.js"></script>
    <script src="libs/babel.min.js"></script>
    <script src="libs/lucide.min.js"></script>
    <script src="libs/chart.umd.min.js"></script>

    <style>
        
    :root { 
        --adtec-accent: #38bdf8; 
        --bg: #020617; 
        --surface: rgba(15, 23, 42, 0.8); 
        --border: rgba(148, 163, 184, 0.2); 
        --success: #22c55e; 
        --warn: #fbbf24; 
        --danger: #ef4444;
        --text: #f8fafc; 
        --text-muted: #94a3b8;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    .adtec-dashboard-root {
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        min-height: 100vh;
        background: radial-gradient(circle at top, #020617 0, #020617 45%, #000 100%);
        color: #e5e7eb;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    /* LA TARJETA MAESTRA: Copia exacta del Editor */
    .adtec-card { 
        background: linear-gradient(145deg, rgba(15,23,42,0.97), rgba(15,23,42,0.7));
        border-radius: 16px; 
        padding: 25px; 
        position: relative; 
        backdrop-filter: blur(20px);
        border: 1px solid rgba(148, 163, 184, 0.35);
        box-shadow: 0 18px 45px rgba(15,23,42,0.9);
        display: flex; 
        flex-direction: column;
        overflow: hidden;
    }

    .card-header { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        margin-bottom: 20px; 
        border-bottom: 1px solid rgba(148, 163, 184, 0.2); 
        padding-bottom: 15px; 
    }
    
    .logo-section { display: flex; align-items: center; gap: 12px; }
    .logo-icon { 
        width: 30px; height: 30px; 
        background: #fbbf24; 
        border-radius: 8px;
        display: flex; align-items: center; justify-content: center;
        box-shadow: 0 0 15px rgba(251, 191, 36, 0.4);
    }
    .logo-icon-inner { font-size: 9px; font-weight: 900; color: black; letter-spacing: -0.5px; }
    .card-title { font-weight: 600; font-size: 18px; letter-spacing: 0.05em; color: #f8fafc; margin: 0; }

    .tabs-nav { display: flex; gap: 8px; margin-bottom: 15px; overflow-x: auto; padding-bottom: 5px; width: 100%; justify-content: center; }
    .tab-btn { 
        padding: 10px 20px; cursor: pointer; border-radius: 10px; font-size: 12px; font-weight: 700;
        transition: all 0.2s; color: var(--text-muted); border: 1px solid transparent;
        display: flex; align-items: center; gap: 10px; white-space: nowrap; text-transform: uppercase;
    }
    .tab-btn:hover { background: rgba(255,255,255,0.05); color: var(--text); }
    .tab-btn.active { background: rgba(56, 189, 248, 0.1); border-color: rgba(56, 189, 248, 0.2); color: var(--adtec-accent); }

    .card-body { 
        position: relative; background: rgba(0,0,0,0.2); border-radius: 12px; 
        border: 1px solid rgba(148, 163, 184, 0.1); overflow: hidden; flex: 1;
        display: flex; flex-direction: column;
    }
    .card-body-flat { 
        position: relative; flex: 1; display: flex; flex-direction: column;
    }
    .grid-bg { 
        position: absolute; inset: 0; 
        background-image: radial-gradient(rgba(56, 189, 248, 0.05) 1px, transparent 1px); 
        background-size: 30px 30px; opacity: 0.5; pointer-events: none;
    }

    .widgets-area { position: relative; width: 100%; height: 100%; z-index: 1; flex: 1; }

    /* LOS WIDGETS: Copia exacta del Editor */
    .adtec-status-item { 
        position: absolute; padding: 12px 14px; border-radius: 12px;
        background: radial-gradient(circle at top, rgba(15,118,110,0.15), rgba(15,23,42,0.96));
        border: 1px solid rgba(45,212,191,0.2);
        display: flex; flex-direction: column; gap: 4px;
        transition: all 0.3s ease; backdrop-filter: blur(5px);
    }
    .adtec-status-item h3 { font-size: 10px; text-transform: uppercase; letter-spacing: 0.08em; color: #9ca3af; margin: 0; font-weight: 700; }
    .adtec-status-value { font-size: 20px; font-weight: 700; color: var(--adtec-accent); }
    .adtec-status-sub { font-size: 10px; color: #9ca3af; }
    
    .adtec-temp-bar { 
        width: 100%; height: 6px; background: rgba(15,23,42,0.8); 
        border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 4px; 
        overflow: hidden; margin-top: 5px; position: relative; 
    }
    .adtec-temp-bar-fill { 
        height: 100%; width: 0%; background: var(--adtec-accent);
        box-shadow: 0 0 10px rgba(56, 189, 248, 0.4);
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); 
    }

    .adtec-status-chip { 
        display: inline-flex; align-items: center; gap: 6px; padding: 3px 10px; 
        border-radius: 999px; font-size: 10px; font-weight: 700; margin-top: auto; 
        border: 1px solid rgba(148, 163, 184, 0.3); text-transform: uppercase; letter-spacing: 0.5px;
    }
    .adtec-status-chip.on { background: rgba(34,197,94,0.1); color: #22c55e; border-color: rgba(34,197,94,0.4); }
    .adtec-status-chip.warn { background: rgba(251,191,36,0.1); color: #fbbf24; border-color: rgba(251,191,36,0.4); }
    .adtec-status-chip.off { background: rgba(239,68,68,0.1); color: #ef4444; border-color: rgba(239,68,68,0.4); }
    
    .adtec-status-dot { width: 7px; height: 7px; border-radius: 50%; background: #9ca3af; }
    .adtec-status-dot.on { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
    .adtec-status-dot.warn { background: #fbbf24; box-shadow: 0 0 10px #fbbf24; }
    .adtec-status-dot.off { background: #ef4444; box-shadow: 0 0 10px #ef4444; }

    .vfd-btn { 
        flex: 1; padding: 6px; border-radius: 4px; 
        border: 1px solid rgba(255,255,255,0.1); color: white; 
        font-weight: 800; font-size: 10px; cursor: pointer; 
        transition: all 0.2s; background: rgba(255,255,255,0.05);
        text-transform: uppercase; letter-spacing: 0.05em;
        display: inline-flex; align-items: center; justify-content: center; gap: 4px;
    }
    .vfd-btn:hover { background: rgba(255,255,255,0.1); }
    .vfd-btn:active { transform: scale(0.98); }
    .vfd-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .vfd-btn.start { background: rgba(34, 197, 94, 0.2); color:rgb(214, 245, 245); border-color: #22c55e; }
    .vfd-btn.stop { background: rgba(239, 68, 68, 0.2); color:rgb(255, 204, 204); border-color: #ef4444; }

    .adtec-security-banner {
        margin-top: 25px; padding: 15px 20px; 
        background: rgba(250,204,21,0.05); border-radius: 10px; 
        border: 1px solid rgba(250,204,21,0.2); display: flex; 
        gap: 15px; alignItems: center;
    }
    .adtec-security-banner p { margin: 0; fontSize: 11px; color: #fbbf24; lineHeight: 1.5; }


    .vfd-dial {
        width: 100px; height: 100px; border-radius: 50%; border: 6px solid #1e293b; 
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        background: rgba(0,0,0,0.2); transition: all 0.3s ease; position: relative;
    }
    .vfd-dial.on { border-top-color: var(--adtec-accent); box-shadow: 0 0 15px rgba(56,189,248,0.2); }
    .vfd-dial-value { font-size: 18px; font-weight: 900; color: white; }
    .vfd-dial.on .vfd-dial-value { color: var(--adtec-accent); }
    .vfd-dial-unit { font-size: 8px; color: #9ca3af; }

    .switch { position: relative; display: inline-block; width: 38px; height: 22px; transform: scale(0.7); }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { 
        position: absolute; cursor: pointer; inset: 0; 
        background-color: rgba(148, 163, 184, 0.2); transition: .2s; border-radius: 22px; 
    }
    .slider:before { 
        position: absolute; content: ""; height: 16px; width: 16px; 
        left: 3px; bottom: 3px; background-color: white; transition: .2s; border-radius: 50%; 
    }
    input:checked + .slider { background-color: var(--adtec-accent); }
    input:checked + .slider:before { transform: translateX(16px); }

    .gsm-bars { display: flex; gap: 2px; align-items: flex-end; height: 20px; }
    .gsm-bar { width: 3px; background: rgba(255,255,255,0.1); border-radius: 1px; }
    .gsm-bar.active { background: var(--adtec-accent); box-shadow: 0 0 8px var(--adtec-accent); }

    .adtec-label-widget {
        pointer-events: none; white-space: pre-wrap; font-family: 'Segoe UI', sans-serif;
        display: flex; align-items: center; justify-content: center; text-align: center;
    }

    .adtec-sparkline-container {
        width: 100%;
        height: 45px;
        margin-top: 12px;
        overflow: visible;
        position: relative;
    }
    /* Punto 2: Removido para usar motor real */
    .adtec-sparkline-svg {
        width: 100%;
        height: 100%;
        display: block;
    }
    .adtec-sparkline-path {
        fill: none;
        stroke-width: 1.5;
        stroke-linecap: round;
        stroke-linejoin: round;
        vector-effect: non-scaling-stroke;
    }

    .alert-badge {
        background: #ef4444;
        color: white;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 10px;
        position: absolute;
        top: -5px;
        right: -5px;
        box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        animation: pulse 2s infinite;
        font-weight: 800;
        z-index: 10;
    }

    .alert-card-item {
        background: rgba(30, 41, 59, 0.5);
        border-radius: 12px;
        display: flex;
        overflow: hidden;
        border: 1px solid rgba(148, 163, 184, 0.1);
        transition: transform 0.2s;
    }
    
    .alert-card-side {
        width: 6px;
        background: #ef4444;
        flex-shrink: 0;
    }

    .alert-card-content {
        padding: 16px;
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .alert-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .alert-card-tag {
        background: #ef4444;
        color: white;
        font-size: 9px;
        font-weight: 900;
        padding: 2px 8px;
        border-radius: 4px;
        letter-spacing: 0.05em;
    }

    .alert-card-time {
        font-size: 11px;
        color: #94a3b8;
    }

    .alert-card-msg {
        font-size: 16px;
        font-weight: 700;
        color: #f8fafc;
    }

    .alert-card-detail {
        font-size: 12px;
        color: #94a3b8;
    }

    @keyframes pulse {
        0% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.1); opacity: 0.8; }
        100% { transform: scale(1); opacity: 1; }
    }

    /* Definici√≥n Global de Degradados por Porcentaje */
    .gauge-gradient-normal {
        --grad-start: var(--gauge-pct-0, #10b981);
        --grad-mid: var(--gauge-pct-50, #f59e0b);
        --grad-end: var(--gauge-pct-100, #ef4444);
    }

    .gauge-gradient-inverted {
        --grad-start: var(--gauge-pct-100, #ef4444);
        --grad-mid: var(--gauge-pct-50, #f59e0b);
        --grad-end: var(--gauge-pct-0, #10b981);
    }

        body { 
            margin: 0; 
            padding: 0; 
            background: #020617; 
            overflow-x: hidden; 
        }
    </style>
</head>
<body>
    <div id="dashboard-root"></div>
    
    <!-- Sistema de Diagn√≥stico de Errores -->
    <div id="error-fallback" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#0f172a; color:#f8fafc; font-family:sans-serif; padding:40px; box-sizing:border-box; z-index:9999;">
        <h1 style="color:#ef4444; margin-bottom:20px;">‚ùå Error de Renderizado</h1>
        <p style="font-size:18px; line-height:1.6;">El dashboard no pudo iniciarse correctamente. Esto suele deberse a un error en la configuraci√≥n o un problema en el script de React.</p>
        <div id="error-details" style="background:#1e293b; padding:20px; border-radius:12px; border:1px solid #334155; margin-top:20px; font-family:monospace; white-space:pre-wrap; color:#94a3b8; max-height:400px; overflow-y:auto;"></div>
        <button onclick="window.location.reload()" style="margin-top:30px; padding:12px 25px; background:#38bdf8; color:#0f172a; border:none; border-radius:8px; font-weight:bold; cursor:pointer;">REINTENTAR CARGA</button>
    </div>

    <script type="text/babel">
        try {
            
        const CONFIG = {
            dashboard: {"tabs":[{"id":"1","name":"Estado Actual","icon":"layout-dashboard","title":"Estado Actual del Invernadero","width":970,"height":816,"type":"dashboard"},{"id":"5","name":"Laboratorio de GR√°ficos","icon":"activity","title":"Laboratorio de Gr√°ficos","width":1000,"height":700,"type":"charts"},{"id":"3","name":"Control","icon":"gamepad-2","title":"Control Remoto de Invernadero","width":700,"height":800,"type":"control"},{"id":"4","name":"Alertas","icon":"bell","title":"Alertas","width":1000,"height":700,"type":"alerts"}],"widgets":[{"id":"w_1768270825285","type":"gauge","label":"Humedad del Invernadero","key":"dht22_1_HUM_OUT","unit":"%","min":0,"max":100,"x":240,"y":10,"w":220,"h":180,"tabId":"1","format":"fixed1","showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270831388","type":"gauge","label":"Temperatura del Invernadero","key":"dht22_1_TEMP_OUT","unit":"¬∞C","min":0,"max":50,"x":10,"y":10,"w":220,"h":180,"tabId":"1","format":"fixed1","showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270903173","type":"gauge","label":"Temperatura Exterior","key":"ds18b20_2_TEMP_OUT","unit":"¬∞C","min":0,"max":50,"x":10,"y":210,"w":220,"h":180,"tabId":"1","format":"fixed1","showSparkline":true,"showMinMax":true,"inverted":false,"hideKey":true},{"id":"w_1768270908326","type":"gauge","label":"Temperatura de Pozo","key":"ds18b20_1_TEMP_OUT","unit":"¬∞C","min":0,"max":50,"x":240,"y":210,"w":220,"h":180,"tabId":"1","format":"fixed1","showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270938829","type":"gauge","label":"Frecuencia Ventiladores Pared","key":"vfd_1_FREQ_OUT","unit":"Hz","min":0,"max":70,"x":10,"y":410,"w":220,"h":180,"tabId":"1","format":"fixed1","inverted":false,"showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270972142","type":"gauge","label":"Luxes","key":"tsl2561_1_LUX_OUT","unit":"LX","min":0,"max":40000,"x":240,"y":410,"w":220,"h":180,"tabId":"1","format":"fixed1","showMinMax":true,"showSparkline":true,"hideKey":true},{"id":"w_1768270996596","type":"indicator","label":"Estado Bomba de Agua","key":"relay_3_STATE_OUT","min":0,"max":100,"x":500,"y":120,"w":180,"h":80,"tabId":"1","format":"bool_onoff","hideKey":true},{"id":"w_1768271000492","type":"location","label":"GPS","key":"gsm_1_LOCATION","min":0,"max":100,"x":710,"y":600,"w":200,"h":85,"tabId":"1","format":"fixed1","hideKey":true,"statusKey":"gsm_1_CITY_COUNTRY"},{"id":"w_1768271019292","type":"indicator","label":"Estado de Ventiladores Axiales","key":"vfd_1_STATE_OUT","min":0,"max":100,"x":500,"y":450,"w":180,"h":80,"tabId":"1","format":"bool_onoff","hideKey":true},{"id":"w_1768271019940","type":"indicator","label":"Estado Vent. 2","key":"relay_2_STATE_OUT","min":0,"max":100,"x":500,"y":340,"w":180,"h":80,"tabId":"1","format":"bool_onoff","hideKey":true},{"id":"w_1768271020388","type":"indicator","label":"Estado Vent. 1","key":"relay_1_STATE_OUT","min":0,"max":100,"x":500,"y":230,"w":180,"h":80,"tabId":"1","format":"bool_onoff","hideKey":true},{"id":"w_1768271034349","type":"text","label":"Uso Ventiladores Axiales","key":"vfd_1_RUNTIME_OUT","unit":"Hs","min":0,"max":100,"x":700,"y":450,"w":200,"h":90,"tabId":"1","format":"time_hm","hideKey":true,"showMinMax":true},{"id":"w_1768271034900","type":"text","label":"Uso Ventiladores 3 - 4","key":"relay_2_RUNTIME_OUT","unit":"Hs","min":0,"max":100,"x":700,"y":340,"w":200,"h":90,"tabId":"1","format":"time_hm","hideKey":true,"showMinMax":true},{"id":"w_1768271035300","type":"text","label":"Uso Ventiladores 1 - 2","key":"relay_1_RUNTIME_OUT","unit":"Hs","min":0,"max":100,"x":700,"y":230,"w":200,"h":90,"tabId":"1","format":"time_hm","hideKey":true,"showMinMax":true},{"id":"w_1768271035668","type":"text","label":"Uso Bomba de Agua","key":"relay_3_RUNTIME_OUT","unit":"Hs","min":0,"max":100,"x":700,"y":120,"w":200,"h":90,"tabId":"1","format":"time_hm","hideKey":true,"showMinMax":true},{"id":"w_1768271685572","type":"control-relay","label":"Estado Bomba de Agua","key":"relay_3_STATE_OUT","target":"relay_3","min":0,"max":100,"x":30,"y":10,"w":220,"h":120,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768271690253","type":"control-relay","label":"Estado Vent. 1","key":"relay_1_STATE_OUT","target":"relay_1","min":0,"max":100,"x":30,"y":140,"w":220,"h":120,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768271692422","type":"control-relay","label":"Estado Vent. 2","key":"relay_2_STATE_OUT","target":"relay_2","min":0,"max":100,"x":30,"y":270,"w":220,"h":120,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768271697991","type":"control-vfd","label":"Frecuencia Ventiladores Pared","key":"vfd_1_FREQ_OUT","target":"vfd_1","min":0,"max":100,"x":330,"y":110,"w":260,"h":280,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768272928661","type":"control-relay","label":"Estado de Ventiladores Axiales","key":"vfd_1_STATE_OUT","target":"vfd_1","min":0,"max":100,"x":30,"y":400,"w":220,"h":120,"tabId":"3","format":"fixed1","hideKey":true},{"id":"w_1768842671728","type":"text","label":"Ultima Alerta","key":"sin_key","unit":"","min":0,"max":0,"x":10,"y":600,"w":680,"h":90,"tabId":"1","format":"fixed1","borderRadius":12,"boxShadow":"0 0 10px","showBar":false,"hideKey":true},{"id":"w_1768844189895","type":"datetime","label":"Reloj Sistema","key":"timestamp","unit":"Hs","min":0,"max":0,"x":490,"y":10,"w":220,"h":85,"tabId":"1","format":"datetime_hm_full","borderRadius":12,"boxShadow":"0 0 10px","showBar":false,"hideKey":true},{"id":"w_1768844223684","type":"connection","label":"Estado Red","key":"gsm_signal","min":0,"max":0,"x":720,"y":10,"w":180,"h":85,"tabId":"1","format":"fixed1","borderRadius":12,"boxShadow":"0 0 10px","showBar":false,"signalKey":"gsm_1_SIGNAL","statusKey":"gsm_1_STATE","hideKey":true}],"variables":[{"key":"dht22_1_HUM_OUT","label":"Humedad del Invernadero","dataType":"HUM"},{"key":"dht22_1_TEMP_OUT","label":"Temperatura del Invernadero","dataType":"TEMP"},{"key":"ds18b20_2_TEMP_OUT","label":"Temperatura Exterior","dataType":"TEMP"},{"key":"relay_3_STATE_OUT","label":"Estado Bomba de Agua","dataType":"STATE"},{"key":"relay_1_STATE_OUT","label":"Estado Vent. 1","dataType":"STATE"},{"key":"relay_2_STATE_OUT","label":"Estado Vent. 2","dataType":"STATE"},{"key":"vfd_1_FREQ_OUT","label":"Frecuencia Ventiladores Pared","dataType":""},{"key":"relay_3_RUNTIME_OUT","label":"Uso Bomba de Agua","dataType":""},{"key":"relay_1_RUNTIME_OUT","label":"Uso Ventiladores 1 - 2","dataType":""},{"key":"relay_2_RUNTIME_OUT","label":"Uso Ventiladores 3 - 4","dataType":""},{"key":"vfd_1_STATE_OUT","label":"Estado de Ventiladores Axiales","dataType":"STATE"},{"key":"vfd_1_RUNTIME_OUT","label":"Uso Ventiladores Axiales","dataType":""},{"key":"ds18b20_1_TEMP_OUT","label":"Temperatura de Pozo","dataType":"TEMP"},{"key":"tsl2561_1_LUX_OUT","label":"Luxes","dataType":"LUX"},{"key":"gsm_1_SIGNAL","label":"Signal GSM","dataType":"SIGNAL"},{"key":"gsm_1_STATE","label":"Estado GSM","dataType":"STATE"},{"key":"gsm_1_LOCATION","label":"GPS","dataType":"LOCATION"},{"key":"gsm_1_CITY_COUNTRY","label":"City, Country","dataType":"LOCATION"}],"actuators":[{"id":"relay_1","label":"relay_1","type":"ACT_RELAY_SINGLE"},{"id":"relay_2","label":"relay_2","type":"ACT_RELAY_SINGLE"},{"id":"vfd_1","label":"vfd_1","type":"ACT_VFD_MODBUS"},{"id":"relay_3","label":"relay_3","type":"ACT_RELAY_SINGLE"}]},
            labels: {"dht22_1_HUM_OUT":"Humedad del Invernadero","dht22_1_TEMP_OUT":"Temperatura del Invernadero","ds18b20_2_TEMP_OUT":"Temperatura Exterior","relay_3_STATE_OUT":"Estado Bomba de Agua","relay_1_STATE_OUT":"Estado Vent. 1","relay_2_STATE_OUT":"Estado Vent. 2","vfd_1_FREQ_OUT":"Frecuencia Ventiladores Pared","relay_3_RUNTIME_OUT":"Uso Bomba de Agua","relay_1_RUNTIME_OUT":"Uso Ventiladores 1 - 2","relay_2_RUNTIME_OUT":"Uso Ventiladores 3 - 4","vfd_1_STATE_OUT":"Estado de Ventiladores Axiales","vfd_1_RUNTIME_OUT":"Uso Ventiladores Axiales","ds18b20_1_TEMP_OUT":"Temperatura de Pozo","tsl2561_1_LUX_OUT":"Luxes","gsm_1_SIGNAL":"Signal GSM","gsm_1_STATE":"Estado GSM","gsm_1_LOCATION":"GPS","gsm_1_CITY_COUNTRY":"City, Country"},
            refreshInterval: 1000,
            chartConfig: {
                primaryY: '',
                secondaryY: '',
                timeRange: 'Ahora'
            }
        };
        
        const formatValue = (val, format, unit = "") => {
            if (val === null || val === undefined || val === '--') return "--";
            
            const num = parseFloat(val);
            const isNum = !isNaN(num);
            if (!isNum) return val + unit;

            // BLINDAJE PUNTO 4: Si es el valor centinela de error, no mostrar n√∫mero
            if (num === -50.0) return "--";

            if (format === 'fixed1') return num.toFixed(1) + unit;
            if (format === 'fixed2') return num.toFixed(2) + unit;
            
            const isDateStr = typeof val === 'string' && (val.includes('T') || (val.includes('-') && val.includes(':')));

            // Formatos de Tiempo y Fecha
            if (format?.startsWith('datetime') || ((format === 'time_hm' || format === 'time_hms') && isDateStr)) {
                try {
                    const d = new Date(val);
                    if (!isNaN(d.getTime())) {
                        const showSeconds = format === 'time_hms' || format === 'datetime_full' || format === 'raw';
                        const time = d.toLocaleTimeString('es-ES', { 
                            hour: '2-digit', minute: '2-digit', 
                            second: showSeconds ? '2-digit' : undefined 
                        });
                        const dateStr = d.toLocaleDateString('es-ES', { weekday: 'long', day: '2-digit', month: 'long', year: 'numeric' });
                        const date = dateStr.charAt(0).toUpperCase() + dateStr.slice(1);
                        
                        if (format === 'datetime_full' || format === 'datetime_hm_full') return time + "|" + date;
                        return time;
                    }
                } catch (e) { }
            }

            if (format === 'time_hm' || format === 'time_hms') {
                if (!isNum) return "--"; // Validar que sea num√©rico para formatos de tiempo
                const totalSeconds = Math.floor(num);
                const h = Math.floor(totalSeconds / 3600);
                const m = Math.floor((totalSeconds % 3600) / 60);
                const s = totalSeconds % 60;
                if (format === 'time_hm') return h + ":" + m.toString().padStart(2, '0');
                return h + ":" + m.toString().padStart(2, '0') + ":" + s.toString().padStart(2, '0');
            }

            if (format === 'datetime' || (typeof val === 'string' && val.includes('T') && val.includes(':'))) {
                try {
                    const date = new Date(val);
                    if (!isNaN(date.getTime())) {
                        return date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    }
                } catch (e) { }
            }
            
            if (format === 'bool_onoff') {
                const isTrue = val === true || val === 1 || val === '1' || val === '1.00' || 
                               String(val).toUpperCase() === 'ON' || String(val).toUpperCase() === 'TRUE' || 
                               String(val).toUpperCase() === 'ACTIVO';
                return isTrue ? 'ON' : 'OFF';
            }

            if (format === 'percent') {
                if (!isNum) return "--";
                return num.toFixed(0) + "%";
            }

            if (isNum && typeof val === 'number') {
                return num.toFixed(1) + unit;
            }
            
            if (typeof val === 'string' && val.includes(',')) {
                return val + unit;
            }

            // Si llegamos aqu√≠ y no es num√©rico ni un formato especial, devolvemos --
            if (!isNum && val !== '--') return "--";

            return val + unit;
        };

        const getGaugeColor = (val, key = "") => {
            const num = parseFloat(val);
            if (isNaN(num)) return '#10b981';
            if (key.toLowerCase().includes('temp')) {
                if (num < 15) return '#3b82f6';
                if (num < 30) return '#10b981';
                if (num < 35) return '#f59e0b';
                return '#ef4444';
            }
            if (key.toLowerCase().includes('hum')) {
                if (num < 40) return '#ef4444';
                if (num < 70) return '#10b981';
                return '#f59e0b';
            }
            if (num < 20) return '#10b981';
            if (num < 80) return '#f59e0b';
            return '#ef4444';
        };

        const getGradientByType = (type, alpha, inverted) => {
            let stops = [{ pos: 0, color: '#10b981' }, { pos: 50, color: '#f59e0b' }, { pos: 100, color: '#ef4444' }];
            if (inverted) {
                const colors = stops.map(s => s.color).reverse();
                stops = stops.map((s, i) => ({ ...s, color: colors[i] }));
            }
            const alphaHex = Math.floor(alpha * 255).toString(16).padStart(2, '0');
            return "linear-gradient(90deg, " + stops.map(s => s.color + alphaHex + " " + s.pos + "%").join(", ") + ")";
        };

        // Motor de Minigr√°ficos (Sparkline Engine)
        const SparklineEngine = {
            memory: {},
            BUFFER_SIZE: 100, // Reducido de 750 a 100
            getSafeRange(min, max) {
                const sMin = Number(min) || 0;
                let sMax = Number(max) || 100;
                if (sMax <= sMin) sMax = sMin + 1;
                return { min: sMin, max: sMax, mid: (sMin + sMax) / 2 };
            },
            getBuffer(id, variableKey, min, max) {
                const { mid, min: sMin, max: sMax } = this.getSafeRange(min, max);
                if (!this.memory[id] || this.memory[id].variableKey !== variableKey) {
                    this.memory[id] = {
                        data: new Array(this.BUFFER_SIZE).fill(mid),
                        variableKey: variableKey,
                        hasData: false,
                        lastMin: sMin,
                        lastMax: sMax,
                        dailyMin: undefined,
                        dailyMax: undefined
                    };
                } else {
                    // DETECTAR CAMBIO DE ESCALA EN CALIENTE
                    const buffer = this.memory[id];
                    if (buffer.lastMin !== sMin || buffer.lastMax !== sMax) {
                        const oldMin = buffer.lastMin !== undefined ? buffer.lastMin : 0;
                        const oldMax = buffer.lastMax !== undefined ? buffer.lastMax : 100;
                        const oldRange = Math.max(1, oldMax - oldMin);
                        const newRange = Math.max(1, sMax - sMin);

                        buffer.data = buffer.data.map(val => {
                            const pct = (val - oldMin) / oldRange;
                            return sMin + (pct * newRange);
                        });

                        buffer.lastMin = sMin;
                        buffer.lastMax = sMax;
                    }
                }
                return this.memory[id].data;
            },
            hasRealData(id) {
                return this.memory[id] && this.memory[id].hasData;
            },
            getStats(id) {
                return {
                    min: this.memory[id] ? this.memory[id].dailyMin : undefined,
                    max: this.memory[id] ? this.memory[id].dailyMax : undefined
                };
            },
            // Guardar historial completo en formato [{timestamp, kv}]
            setHistory(id, variableKey, historyRows, min, max) {
                const buffer = this.getBuffer(id, variableKey, min, max);
                const { mid, min: sMin, max: sMax } = this.getSafeRange(min, max);
                if (!historyRows || historyRows.length === 0) return;

                // Registrar primer timestamp conocido para referencias (no inventar horas)
                if (historyRows[0] && historyRows[0].timestamp) this._firstHistoryTimestamp = historyRows[0].timestamp;

                this.memory[id].lastMin = sMin;
                this.memory[id].lastMax = sMax;

                let hMin = Infinity;
                let hMax = -Infinity;

                const incoming = historyRows.map(row => {
                    const raw = (row && row.kv) ? row.kv[variableKey] : (row ? row[variableKey] : undefined);
                    const num = parseFloat(raw);
                    const val = isNaN(num) ? sMin : Math.max(sMin, Math.min(sMax, num));
                    if (!isNaN(num)) {
                        hMin = Math.min(hMin, num);
                        hMax = Math.max(hMax, num);
                    }
                    return val;
                }).slice(-this.BUFFER_SIZE);

                if (hMin !== Infinity) {
                    if (this.memory[id].dailyMin === undefined) {
                        this.memory[id].dailyMin = hMin;
                        this.memory[id].dailyMax = hMax;
                    } else {
                        this.memory[id].dailyMin = Math.min(this.memory[id].dailyMin, hMin);
                        this.memory[id].dailyMax = Math.max(this.memory[id].dailyMax, hMax);
                    }
                }

                if (incoming.length > 0) {
                    buffer.fill(mid);
                    const startIdx = this.BUFFER_SIZE - incoming.length;
                    for (let i = 0; i < incoming.length; i++) {
                        buffer[startIdx + i] = incoming[i];
                    }
                    this.memory[id].hasData = true;
                }
            },
            // Devuelve el primer timestamp almacenado por setHistory o null si no existe
            getTodayStartISO() {
                return this._firstHistoryTimestamp || null;
            },
            update(id, variableKey, newValue, min, max) {
                const buffer = this.getBuffer(id, variableKey, min, max);
                const { min: sMin, max: sMax } = this.getSafeRange(min, max);
                
                this.memory[id].lastMin = sMin;
                this.memory[id].lastMax = sMax;

                let val = parseFloat(newValue);
                const isInvalid = newValue === null || newValue === undefined || newValue === '' || isNaN(val);
                if (isInvalid) {
                    // Mantenemos el √∫ltimo valor para evitar saltos a 0 (especialmente en Luxes)
                    val = buffer[buffer.length - 1];
                } else {
                    val = Math.max(sMin, Math.min(sMax, val));
                    
                    const current = parseFloat(newValue);
                    if (!isNaN(current)) {
                        if (this.memory[id].dailyMin === undefined) {
                            this.memory[id].dailyMin = current;
                            this.memory[id].dailyMax = current;
                        } else {
                            this.memory[id].dailyMin = Math.min(this.memory[id].dailyMin, current);
                            this.memory[id].dailyMax = Math.max(this.memory[id].dailyMax, current);
                        }
                    }
                }
                
                buffer.shift();
                buffer.push(val);
                this.memory[id].hasData = true;
                
                return buffer;
            }
        };

        const getRawWidgetValue = (key, state) => {
            if (!state) return undefined;
            let val = state.telemetry ? state.telemetry[key] : state[key];
            if (val === undefined && state.data && typeof state.data === 'object') val = state.data[key];
            if (val === undefined && state.blocks) {
                for (const blockId in state.blocks) {
                    if (state.blocks[blockId][key] !== undefined) {
                        val = state.blocks[blockId][key];
                        break;
                    }
                }
            }
            if (val === undefined && key.includes('.')) {
                const [blockId, prop] = key.split('.');
                const block = state.blocks && state.blocks[blockId];
                val = block && (block[prop.toLowerCase()] || block[prop]);
            }
            return val;
        };

        const getWidgetValueShared = (key, state, widgets) => {
            if (!state) return '--';
            if (key.toLowerCase() === 'alert_msg' || key.toLowerCase() === 'ultima_alerta' || key.toLowerCase() === 'alerta') {
                const alerts = state.activeAlerts || [];
                if (alerts.length === 0) return 'üü¢ SISTEMA OK';
                const lastAlert = alerts[alerts.length - 1];
                return (lastAlert.type === 'CRITICAL' ? 'üî¥' : 'üü°') + ' ' + lastAlert.message;
            }
            const val = getRawWidgetValue(key, state);
            if (val === undefined) return '--';
            const widget = widgets.find(w => w.key === key);
            return formatValue(val, widget && widget.format, widget && widget.unit);
        };
  
            
const { useState, useEffect, useMemo, useRef, useCallback } = React;
// --- Normalizaci√≥n global (API flat sin kv.) ---
// Quita "kv." si existe
const normKey = (k) => (typeof k === 'string' && k.startsWith('kv.')) ? k.slice(3) : k;
// Lee valor tolerante: primero key limpia, luego prueba "kv."+key por compat
const getVal = (obj, key) => {
    if (!obj || !key) return undefined;
    const nk = normKey(key);
    if (obj[nk] !== undefined) return obj[nk];
    const legacy = 'kv.' + nk;
    if (obj[legacy] !== undefined) return obj[legacy];
    return undefined;
};
// Normaliza cualquier payload a flat sin "kv."
const normalizePoint = (raw) => {
    if (!raw || typeof raw !== 'object') return raw;
    const src = (raw.kv && typeof raw.kv === 'object') ? raw.kv : raw;
    const out = {};
    if (raw.timestamp) out.timestamp = raw.timestamp;
    for (const k in src) {
        if (k === 'timestamp') continue;
        out[normKey(k)] = src[k];
    }
    if (!out.timestamp) out.timestamp = new Date().toISOString();
    return out;
};
// POLLING / LIMITS (A)
const LIVE_MAX_POINTS = 300;
const HISTORY_PRELOAD_LIMIT = 5000;
const LIVE_PRELOAD_LIMIT = 300;
// Cache local para que el dashboard no "arranque vac√≠o" si la red tarda
const HISTORY_CACHE_LIMIT = 1500;
const HISTORY_CACHE_KEY = 'adtec_history_cache_ingreso_v1';
// Poll de alertas desacoplado del loop live (evita spam de GET /api/alerts)
const ALERTS_POLL_MS = (CONFIG.alertsInterval ?? 10000);
// Componente de Gr√°fico Optimizado (Zero-Flicker)
const DashboardChart = React.memo(({ widget, dataHistory, chartConfig }) => {
    const canvasRef = useRef(null);
    const chartRef = useRef(null);
    // Obtener configuraci√≥n de escala (min/max) y formato
    const getScaleSettings = (key) => {
        if (!key) return { min: undefined, max: undefined, format: undefined, unit: "" };
        const nk = normKey(key);
const w = CONFIG.dashboard.widgets.find(w => normKey(w.key) === nk);
        if (!w) return { min: undefined, max: undefined, format: undefined, unit: "" };
        
        // Si es estado digital, escala inicial 0-2
        if (w.format === 'bool_onoff' || w.type === 'indicator' || w.type === 'control-relay') {
            return { min: 0, max: 2, format: 'bool_onoff', unit: w.unit || "" };
        }
        const hasNoLimits = (w.min === 0 && w.max === 0) || (w.min === undefined && w.max === undefined);
        return { 
            min: hasNoLimits ? undefined : w.min, 
            max: hasNoLimits ? undefined : w.max,
            format: w.format,
            unit: w.unit || ""
        };
    };
    useEffect(() => {
        if (!canvasRef.current || typeof Chart === 'undefined') return;
        const ctx = canvasRef.current.getContext('2d');
        const pS = getScaleSettings(chartConfig && chartConfig.primaryY);
        const sS = getScaleSettings(chartConfig && chartConfig.secondaryY);
        chartRef.current = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Eje Principal',
                        data: [],
                        borderColor: '#38bdf8',
                        backgroundColor: 'rgba(56, 189, 248, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Eje Secundario',
                        data: [],
                        borderColor: '#a855f7',
                        backgroundColor: 'rgba(168, 85, 247, 0.05)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.3,
                        pointRadius: 0,
                        yAxisID: 'y1',
                        hidden: !(chartConfig && chartConfig.secondaryY)
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: { 
                        display: true,
                        grid: { color: 'rgba(255,255,255,0.03)' },
                        ticks: { 
                            color: '#64748b', 
                            font: { size: 9 },
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 8 
                        }
                    },
                    y: {
                        display: true,
                        position: 'left',
                        beginAtZero: false,
                        suggestedMin: pS.min,
                        suggestedMax: pS.max,
                        grid: { color: 'rgba(255,255,255,0.05)' }, 
                        ticks: { 
                            color: '#38bdf8', 
                            font: { size: 10 },
                            callback: (val) => formatValue(val, pS.format, "")
                        } 
                    },
                    y1: {
                        display: !!(chartConfig && chartConfig.secondaryY),
                        position: 'right',
                        beginAtZero: false,
                        suggestedMin: sS.min,
                        suggestedMax: sS.max,
                        grid: { drawOnChartArea: false }, 
                        ticks: { 
                            color: '#a855f7', 
                            font: { size: 10 },
                            callback: (val) => formatValue(val, sS.format, "")
                        }
                    }
                },
                    plugins: { 
                        legend: { 
                            display: true,
                            position: 'top',
                            align: 'end',
                            labels: {
                                color: '#f8fafc',
                                font: { size: 11, weight: 'bold' },
                                usePointStyle: true,
                                pointStyle: 'rectRounded',
                                padding: 15
                            }
                        },
                        tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(15, 23, 42, 0.95)',
                        titleColor: '#fff',
                        titleFont: { size: 11, weight: 'bold' },
                        bodyFont: { size: 12 },
                        padding: 10,
                        borderColor: 'rgba(255,255,255,0.1)',
                        borderWidth: 1,
                        callbacks: {
                            title: (items) => {
                                const item = items[0];
                                const rawData = dataHistory[item.dataIndex];
                                if (!rawData || !rawData.fullTimestamp) return item.label;
                                const d = new Date(rawData.fullTimestamp);
                                return d.toLocaleDateString('es-ES') + ' ' + d.toLocaleTimeString('es-ES');
                            },
                            label: (item) => {
                                const label = item.dataset.label || '';
                                const value = item.formattedValue;
                                const unitKey = (item.datasetIndex === 0 ? (chartConfig && chartConfig.primaryY) : (chartConfig && chartConfig.secondaryY));
                                const widgetFound = CONFIG.dashboard.widgets.find(w => w.key === unitKey);
                                const unit = (widgetFound && widgetFound.unit) || '';
                                return label + ': ' + value + ' ' + unit;
                            }
                        }
                    }
                }
            }
        });
        return () => {
            if (chartRef.current) chartRef.current.destroy();
        };
    }, []);
    useEffect(() => {
        const chart = chartRef.current;
        if (!chart || !chartConfig || !chartConfig.primaryY) return;
        
        const pS = getScaleSettings(chartConfig.primaryY);
        const sS = getScaleSettings(chartConfig.secondaryY);
        // Actualizar nombres de variables
        const v1Label = CONFIG.labels[chartConfig.primaryY] || chartConfig.primaryY || 'Variable 1';
        const v2Label = CONFIG.labels[chartConfig.secondaryY] || chartConfig.secondaryY || 'Variable 2';
        const safeHistory = dataHistory || [];
        chart.data.labels = safeHistory.map(d => d.t);
        chart.data.datasets[0].data = safeHistory.map(d => d.v);
        chart.data.datasets[0].label = v1Label;
        if (chartConfig.secondaryY) {
            chart.data.datasets[1].data = dataHistory.map(d => d.v2);
            chart.data.datasets[1].label = v2Label;
            chart.data.datasets[1].hidden = false;
            chart.options.scales.y1.display = true;
        } else {
            chart.data.datasets[1].hidden = true;
            chart.options.scales.y1.display = false;
        }
        // Actualizar l√≠mites din√°micamente con auto-escalado (suggested)
        chart.options.scales.y.suggestedMin = pS.min;
        chart.options.scales.y.suggestedMax = pS.max;
        chart.options.scales.y.ticks.callback = (val) => formatValue(val, pS.format, "");
        if (chartConfig && chartConfig.secondaryY) {
            chart.options.scales.y1.suggestedMin = sS.min;
            chart.options.scales.y1.suggestedMax = sS.max;
            chart.options.scales.y1.ticks.callback = (val) => formatValue(val, sS.format, "");
        }
        chart.update('none');
    }, [dataHistory, chartConfig]);
    return <canvas ref={canvasRef} style={{ display: 'block', width: '100%', height: '100%' }} />;
});
// Componente de Minigr√°fico (Sparkline) - Motor Pro de 100 puntos
const Sparkline = React.memo(({ id, variableKey, min, max, inverted, value, historyTick }) => {
    // Estado local para asegurar dibujo sincronizado
    const [points, setPoints] = useState(() => {
        const initial = SparklineEngine.getBuffer(id, variableKey, min, max);
        return [...initial];
    });
    useEffect(() => {
        // Solo obtener el buffer actual
        // El motor es actualizado de forma centralizada en fetchUpdate y fetchHistory
        const currentPoints = SparklineEngine.getBuffer(id, variableKey, min, max);
        setPoints([...currentPoints]);
    }, [id, variableKey, value, min, max, historyTick]);
    const hasData = useMemo(() => SparklineEngine.hasRealData(id), [id, value, historyTick]);
    const isDisconnected = value === undefined || value === null || value === '' || isNaN(parseFloat(value));
    const pathData = useMemo(() => {
        if (points.length === 0) return "";
        const width = 100;
        const height = 50;
        // Ajuste de margen para visibilidad de Luxes y valores m√≠nimos
        const padding = 4; 
        const safeHeight = height - (padding * 2);
        
        // Sincronizar con motor
        const sMin = Number(min) || 0;
        let sMax = Number(max);
        if (isNaN(sMax)) sMax = 100;
        if (sMax <= sMin) sMax = sMin + 1;
        const range = sMax - sMin;
        
        return points.map((val, i) => {
            const x = (i / (points.length - 1)) * width;
            // Blindaje: fijar al borde si excede (dentro del √°rea segura)
            const cappedVal = Math.max(sMin, Math.min(sMax, val));
            const pct = (cappedVal - sMin) / range;
            const y = (height - padding) - (pct * safeHeight);
            return (i === 0 ? 'M' : 'L') + " " + x + " " + y;
        }).join(' ');
    }, [points, min, max]);
    // Color de la l√≠nea: Degradado real por defecto. Azul de Diagn√≥stico SOLO si hubo datos y se perdieron.
    const strokeColor = (hasData && isDisconnected) ? "#3b82f6" : "url(#grad-final-" + id + ")";
    // Asegurar que las variables de color existan para el degradado
    const sparklineColors = {
        '--grad-start': inverted ? '#ef4444' : '#10b981',
        '--grad-mid': '#f59e0b',
        '--grad-end': inverted ? '#10b981' : '#ef4444'
    };
    return React.createElement('div', { 
        className: 'adtec-sparkline-container ' + (inverted ? 'gauge-gradient-inverted' : 'gauge-gradient-normal'),
        style: { 
            marginTop: '7px', 
            ...sparklineColors,
            background: 'rgba(0,0,0,0.2)',
            borderRadius: '8px',
            overflow: 'hidden',
            border: '1px solid rgba(148,163,184,0.05)',
            display: 'flex',
            alignItems: 'center',
            height: '50px'
        }
    }, [
        React.createElement('svg', { 
            key: 'svg',
            className: 'adtec-sparkline-svg', 
            viewBox: '0 -5 100 60', 
            preserveAspectRatio: 'none',
            style: { height: '50px', flex: 1 }
        }, [
            React.createElement('defs', { key: 'defs' }, [
                React.createElement('linearGradient', { 
                    key: 'grad',
                    id: "grad-final-" + id, 
                    x1: "0", y1: "50", x2: "0", y2: "0",
                    gradientUnits: "userSpaceOnUse"
                }, [
                    /* Colores en RGB puro para asegurar visibilidad absoluta */
                    React.createElement('stop', { key: 's1', offset: "0%", stopColor: "var(--grad-start, rgb(16, 185, 129))" }),
                    React.createElement('stop', { key: 's2', offset: "50%", stopColor: "var(--grad-mid, rgb(245, 158, 11))" }),
                    React.createElement('stop', { key: 's3', offset: "100%", stopColor: "var(--grad-end, rgb(239, 68, 68))" })
                ]),
                /* Fondo Degradado Tenue/Brilloso */
                React.createElement('linearGradient', { 
                    key: 'bg-grad',
                    id: "bg-grad-final-" + id, 
                    x1: "0", y1: "1", x2: "0", y2: "0"
                }, [
                    React.createElement('stop', { key: 'b1', offset: "0%", stopColor: "rgba(56, 189, 248, 0.02)" }),
                    React.createElement('stop', { key: 'b2', offset: "50%", stopColor: "rgba(56, 189, 248, 0.1)" }),
                    React.createElement('stop', { key: 'b3', offset: "100%", stopColor: "rgba(56, 189, 248, 0.02)" })
                ])
            ]),
            /* Fondo Degradado Tenue */
            React.createElement('rect', { 
                key: 'bg-rect',
                x: "0", y: "0", width: "100", height: "50", 
                fill: "url(#bg-grad-final-" + id + ")", 
                opacity: "0.6" 
            }),
            /* L√≠neas de Gu√≠a de Fondo */
            React.createElement('line', { key: 'g1', x1: "0", y1: "0", x2: "100", y2: "0", stroke: "rgba(255,255,255,0.05)", strokeWidth: "0.5" }),
            React.createElement('line', { key: 'g2', x1: "0", y1: "25", x2: "100", y2: "25", stroke: "rgba(255,255,255,0.05)", strokeWidth: "0.5", strokeDasharray: "2,2" }),
            React.createElement('line', { key: 'g3', x1: "0", y1: "50", x2: "100", y2: "50", stroke: "rgba(255,255,255,0.05)", strokeWidth: "0.5" }),
            React.createElement('path', {
                key: 'path',
                d: pathData,
                className: 'adtec-sparkline-path',
                stroke: strokeColor,
                fill: 'none',
                strokeWidth: '2',
                strokeLinecap: 'round',
                strokeLinejoin: 'round'
            })
        ])
    ]);
});
const DashboardApp = () => {
    const [activeTabId, setActiveTabId] = useState((CONFIG.dashboard.tabs[0] && CONFIG.dashboard.tabs[0].id) || '0');
    const [lastData, setLastData] = useState({});
    const [alerts, setAlerts] = useState([]);
    const [controlState, setControlState] = useState({});
    const [pendingCommands, setPendingCommands] = useState({}); 
    // Tick independiente para refrescar sparklines (evita quedar "pegados" hasta cambiar pesta√±a)
    const [sparkTick, setSparkTick] = useState(0);
    const [cacheApiSnapshot, setCacheApiSnapshot] = useState(null);
    const [dayStatsLive, setDayStatsLive] = useState({}); // min/max runtime: seed snapshot then extend with live
    const cacheApiDayFromRef = useRef(null);
    const [cacheApiEtag, setCacheApiEtag] = useState(null);
    const cacheApiLastFetchRef = useRef(0);
    const [historyData, setHistoryData] = useState([]); 
    const [liveData, setLiveData] = useState([]); 
    const [seriesData, setSeriesData] = useState([]);
    const [seriesLoading, setSeriesLoading] = useState(false);
    const [chartConfig, setChartConfig] = useState({
        ...CONFIG.chartConfig,
        filter: 'all',
        fromDate: '',
        toDate: '',
        timeRange: 'Ahora'
    });
    const [connStatus, setConnStatus] = useState('CONECTANDO...');
    const [connColor, setConnColor] = useState('#f59e0b');
    const [lastPacketTime, setLastPacketTime] = useState(0);
    const [lastArrivalLocal, setLastArrivalLocal] = useState(Date.now());
    const [currentDelta, setCurrentDelta] = useState(300000); // 5 min inicial (Aprendizaje)
    const [isLearning, setIsLearning] = useState(true);
    const BASE_URL = CONFIG.BASE_URL || "";

    // --- ACK local de alertas (no borra historial en el Bridge) ---
    const [alertsSeenUntilMs, setAlertsSeenUntilMs] = useState(() => {
        try {
            const v = Number(localStorage.getItem('adtec_alerts_seen_until_ms') || 0);
            return Number.isFinite(v) ? v : 0;
        } catch(e) { return 0; }
    });
    const setSeenUntil = (ms) => {
        try { localStorage.setItem('adtec_alerts_seen_until_ms', String(ms)); } catch(e) {}
        setAlertsSeenUntilMs(ms);
    };
    const getAlertMs = (a) => {
        if (!a) return 0;
        if (a.ts != null) return Number(a.ts) * 1000;
        const iso = a.ts_iso || a.timestamp || a.time || a.date;
        const t = iso ? new Date(iso).getTime() : 0;
        return Number.isFinite(t) ? t : 0;
    };

    // Helpers: datetime-local (sin timezone expl√≠cito, usa local del browser)
    const pad2dt = (n) => String(n).padStart(2, '0');
    const toDatetimeLocal = (ts) => {
        const d = (ts instanceof Date) ? ts : new Date(ts);
        if (!(d instanceof Date) || isNaN(d.getTime())) return '';
        return d.getFullYear() + '-' + pad2dt(d.getMonth()+1) + '-' + pad2dt(d.getDate()) + 'T' + pad2dt(d.getHours()) + ':' + pad2dt(d.getMinutes());
    };
    // Memoria persistente para ubicaci√≥n (Latching)
    const [lastValidLocation, setLastValidLocation] = useState({ city: '--', coord: '--' });
    useEffect(() => {
        const currentLoc = getWidgetValueShared('gsm_location', lastData, CONFIG.dashboard.widgets);
        const currentCity = getWidgetValueShared('gsm_city_country', lastData, CONFIG.dashboard.widgets);
        
        if (currentLoc !== '--' && currentLoc !== '') {
            setLastValidLocation(prev => ({
                city: (currentCity !== '--' && currentCity !== '') ? currentCity : prev.city,
                coord: currentLoc
            }));
        }
    }, [lastData]);
    const getWidgetValue = (key) => getWidgetValueShared(key, lastData, CONFIG.dashboard.widgets);
    const currentTab = useMemo(() => 
        CONFIG.dashboard.tabs.find(t => String(t.id) === String(activeTabId)) || CONFIG.dashboard.tabs[0] || { width: 1000, height: 700 }
    , [activeTabId, CONFIG.dashboard.tabs]);
    useEffect(() => {
        if (!chartConfig.primaryY && CONFIG.dashboard.variables && CONFIG.dashboard.variables.length > 0) {
            setChartConfig(prev => ({ ...prev, primaryY: CONFIG.dashboard.variables[0].key }));
        }
    }, []);
    const normalizeKey = (k) => (typeof k === "string" && k.startsWith("kv.")) ? k.slice(3) : k;
        const normalizeRow = (obj) => { const out = {}; for (const [k,v] of Object.entries(obj||{})) out[normalizeKey(k)] = v; return out; };

// --- Min/Max runtime helpers (seed snapshot, extend with live extremes) ---
const getSnapDayFromTs = (snap) => {
    if (!snap) return null;
    return (snap.day_from_ts ?? (snap.ranges && snap.ranges.day_from_ts) ?? null);
};

const pickMin = (a, b) => {
    const A = (a === null || a === undefined) ? null : Number(a);
    const B = (b === null || b === undefined) ? null : Number(b);
    if (A === null && B === null) return null;
    if (A === null) return Number.isFinite(B) ? B : null;
    if (B === null) return Number.isFinite(A) ? A : null;
    if (!Number.isFinite(A) && Number.isFinite(B)) return B;
    if (!Number.isFinite(B) && Number.isFinite(A)) return A;
    if (!Number.isFinite(A) && !Number.isFinite(B)) return null;
    return Math.min(A, B);
};

const pickMax = (a, b) => {
    const A = (a === null || a === undefined) ? null : Number(a);
    const B = (b === null || b === undefined) ? null : Number(b);
    if (A === null && B === null) return null;
    if (A === null) return Number.isFinite(B) ? B : null;
    if (B === null) return Number.isFinite(A) ? A : null;
    if (!Number.isFinite(A) && Number.isFinite(B)) return B;
    if (!Number.isFinite(B) && Number.isFinite(A)) return A;
    if (!Number.isFinite(A) && !Number.isFinite(B)) return null;
    return Math.max(A, B);
};

const isValidForMinMax = (key, v) => {
    const n = Number(v);
    if (!Number.isFinite(n)) return false;

    // DHT22 muerto suele spamear 0.0: NO contaminar min/max del d√≠a
    const k = String(key || "");
    const isDht22 = /^dht22_/i.test(k) || k.toLowerCase().includes("dht22");
    const isTempHum = /_(TEMP_OUT|HUM_OUT)$/i.test(k);
    if (isDht22 && isTempHum && n === 0) return false;

    return true;
};

	// Latching de fechas del chart: LIVE/24h/7d actualizan from/to con primer/√∫ltimo punto.
	// Al entrar a Rango, se congela y el usuario edita.
	const latchChartDates = useCallback((fromTsLike, toTsLike) => {
		if (!fromTsLike || !toTsLike) return;
		const fromL = toDatetimeLocal(fromTsLike);
		const toL = toDatetimeLocal(toTsLike);
		if (!fromL || !toL) return;
		setChartConfig(prev => {
			if (prev.timeRange === 'Rango') return prev;
			if (prev.fromDate === fromL && prev.toDate === toL) return prev;
			return { ...prev, fromDate: fromL, toDate: toL };
		});
	}, []);
        
const mergeByTimestamp = (rowsA, rowsB) => {
    const map = new Map();
    for (const r of (rowsA || [])) {
        if (!r || !r.timestamp) continue;
        map.set(r.timestamp, { ...r });
    }
    for (const r of (rowsB || [])) {
        if (!r || !r.timestamp) continue;
        const prev = map.get(r.timestamp);
        map.set(r.timestamp, prev ? { ...prev, ...r } : { ...r });
    }
    return Array.from(map.values()).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
};
const fetchSeriesPrimary = async () => {
    try {
        const isLive = chartConfig.timeRange === 'Ahora';
        if (!chartConfig.primaryY || isLive) {
            setSeriesData([]);
            return;
        }

        setSeriesLoading(true);

        const y1 = normalizeKey(chartConfig.primaryY);
        const y2 = chartConfig.secondaryY ? normalizeKey(chartConfig.secondaryY) : null;

        const nowSec = Math.floor(Date.now() / 1000);
        let fromTs = null, toTs = nowSec;

        const isRange = chartConfig.timeRange === 'Rango';

        // Determinar rango
        if (chartConfig.timeRange === '24h') fromTs = nowSec - 86400;
        else if (chartConfig.timeRange === '7d') fromTs = nowSec - (7 * 86400);
        else if (isRange) {
            // si no hay fechas, no pedimos series (evita from_ts=null)
            if (!chartConfig.fromDate || !chartConfig.toDate) {
                setSeriesData([]);
                return;
            }
        }

        const buildSeriesUrl = (key) => {
            const u = new URL(BASE_URL + '/api/series', window.location.origin);
            u.searchParams.set('channel', 'ingreso');
            u.searchParams.set('key', key);
            u.searchParams.set('max_points', '1000');

            if (isRange) {
                u.searchParams.set('from_iso', chartConfig.fromDate);
                u.searchParams.set('to_iso', chartConfig.toDate);
            } else {
                // nunca enviar null
                if (fromTs != null) u.searchParams.set('from_ts', String(fromTs));
                u.searchParams.set('to_ts', String(toTs));
            }
            return u;
        };

        const fetchSeries = async (key) => {
            const u = buildSeriesUrl(key);
            const res = await fetch(u);
            if (!res.ok) return [];
            const js = await res.json();
            const pts = Array.isArray(js?.points) ? js.points : [];
            return pts.map(p => {
                const ts = p?.[0];
                const v = p?.[1];
                return normalizeRow({ timestamp: new Date(ts * 1000).toISOString(), [key]: v });
            });
        };

        const rows1 = await fetchSeries(y1);
        let merged = rows1;

        if (y2 && y2 !== y1) {
            const rows2 = await fetchSeries(y2);
            merged = mergeByTimestamp(rows1, rows2);
        }

        setSeriesData(merged);

        // Debug opcional (no rompe si no lo us√°s)
        window.__seriesData = merged;
    } catch (e) {
        console.warn('fetchSeriesPrimary fall√≥', e);
        setSeriesData([]);
    } finally {
        setSeriesLoading(false);
    }
};

useEffect(() => {
    fetchSeriesPrimary();
}, [chartConfig.timeRange, chartConfig.primaryY, chartConfig.secondaryY, chartConfig.fromDate, chartConfig.toDate]);

// --- Latch de fechas para que nunca queden vac√≠as y para que RANGO arranque con valores editables ---
useEffect(() => {
    // En RANGO: congelar y, si est√° vac√≠o, setear defaults (to=√∫ltimo o now, from=to-24h)
    if (chartConfig.timeRange === 'Rango') {
        if (!chartConfig.fromDate || !chartConfig.toDate) {
            const toTs = (lastData && lastData.timestamp) ? lastData.timestamp : Date.now();
            const toStr = toDatetimeLocal(toTs);
            const fromStr = toDatetimeLocal((new Date(toTs).getTime()) - 86400000);
            setChartConfig(prev => ({ ...prev, fromDate: prev.fromDate || fromStr, toDate: prev.toDate || toStr }));
        }
        return;
    }
    // Quick ranges: setear un fallback inmediato (luego se ajusta al primer/√∫ltimo punto real)
    const nowMs = Date.now();
    if (chartConfig.timeRange === 'Ahora') {
        // si todav√≠a no hay liveData, al menos "to" queda seteado
        const toStr = toDatetimeLocal(nowMs);
        const fromStr = toDatetimeLocal(nowMs - 300000); // 5m
        setChartConfig(prev => ({ ...prev, fromDate: fromStr, toDate: toStr }));
    } else if (chartConfig.timeRange === '24h') {
        setChartConfig(prev => ({ ...prev, fromDate: toDatetimeLocal(nowMs - 86400000), toDate: toDatetimeLocal(nowMs) }));
    } else if (chartConfig.timeRange === '7d') {
        setChartConfig(prev => ({ ...prev, fromDate: toDatetimeLocal(nowMs - 7*86400000), toDate: toDatetimeLocal(nowMs) }));
    }
}, [chartConfig.timeRange]);

// Ajuste fino: LIVE usa primer/√∫ltimo punto real
useEffect(() => {
    if (chartConfig.timeRange !== 'Ahora') return;
    if (!liveData || liveData.length === 0) return;
    const first = liveData[0]?.timestamp;
    const last = liveData[liveData.length - 1]?.timestamp;
    if (first && last) latchChartDates(first, last);
}, [chartConfig.timeRange, liveData]);

// Ajuste fino: 24h/7d usa primer/√∫ltimo punto de seriesData
useEffect(() => {
    if (chartConfig.timeRange !== '24h' && chartConfig.timeRange !== '7d') return;
    if (!seriesData || seriesData.length === 0) return;
    const first = seriesData[0]?.timestamp;
    const last = seriesData[seriesData.length - 1]?.timestamp;
    if (first && last) latchChartDates(first, last);
}, [chartConfig.timeRange, seriesData]);
    
    // --- Precarga server-side de series para Sparklines (1 request, 24h / max_points) ---
    const preloadSparklineHistory = async () => {
        try {
            const sparkWidgets = CONFIG.dashboard.widgets.filter(w => (w.showSparkline || w.type === 'gauge' || w.showMinMax));
            if (!sparkWidgets || sparkWidgets.length === 0) return;

            const keys = Array.from(new Set(sparkWidgets.map(w => normalizeKey(w.key)).filter(Boolean)));
            if (keys.length === 0) return;

            const u = new URL(BASE_URL + '/api/sparkline_series', window.location.origin);
            u.searchParams.set('channel', 'ingreso');
            u.searchParams.set('hours', String(CONFIG.sparklineHours || 24));
            u.searchParams.set('max_points', String(CONFIG.sparklineMaxPoints || 120));
            u.searchParams.set('keys', keys.join(','));

            const res = await fetch(u);
            if (!res.ok) return;
            const js = await res.json();
            const series = js && js.series ? js.series : {};
            if (!series || typeof series !== 'object') return;

            sparkWidgets.forEach(w => {
                const wk = normalizeKey(w.key);
                const pts = Array.isArray(series[wk]) ? series[wk] : [];
                if (pts.length === 0) return;

                const hDataBuffer = pts.map(p => p?.[1]).filter(v => v !== undefined && v !== null);
                // Para min/max del d√≠a, usamos el mismo buffer (el motor ya calcula stats).
                const hDataToday = hDataBuffer;

                try {
                    SparklineEngine.setHistory(w.id, wk, hDataBuffer, w.min, w.max, hDataToday);
                } catch (e) {
                    console.warn('SparklineEngine.setHistory (server series) fall√≥ para', w.id, e);
                }
            });
        } catch (e) {
            console.warn('preloadSparklineHistory fall√≥', e);
        }
    };

    
// --- cache_api snapshot (day_stats + last + alerts) ---
const decodeGzipJson = async (ab) => {
    try {
        if (typeof DecompressionStream === "undefined") return null;
        const ds = new DecompressionStream("gzip");
        const stream = new Response(ab).body.pipeThrough(ds);
        return await new Response(stream).json();
    } catch (e) {
        console.warn("[cache_api] decode failed:", e);
        return null;
    }
};

const fetchCacheApiSnapshot = async (force = false) => {
    try {
        const now = Date.now();
        if (!force && now - (cacheApiLastFetchRef.current || 0) < 55_000) return;
        cacheApiLastFetchRef.current = now;

        const headers = {};
        if (cacheApiEtag) headers["If-None-Match"] = cacheApiEtag;

        const resp = await fetch("/cache_api/snapshot.json.gz", { headers });
        if (resp.status === 304) return;
        if (!resp.ok) return;

        const et = resp.headers.get("etag");
        if (et) setCacheApiEtag(et);

        const ab = await resp.arrayBuffer();
        const json = await decodeGzipJson(ab);
if (json) {
    setCacheApiSnapshot(json);

    // Seed/merge day_stats into runtime min/max (will later extend with live extremes)
    const dayFrom = getSnapDayFromTs(json);
    const incoming = (json && json.day_stats) ? json.day_stats : null;

    if (incoming && typeof incoming === "object") {
        setDayStatsLive(prev => {
            // Reset when day boundary changes
            if (dayFrom !== null && dayFrom !== undefined && cacheApiDayFromRef.current !== dayFrom) {
                cacheApiDayFromRef.current = dayFrom;
                const out = {};
                for (const [k, s] of Object.entries(incoming)) {
                    const kk = normalizeKey(k);
                    const mn = (s && s.min !== undefined) ? s.min : null;
                    const mx = (s && s.max !== undefined) ? s.max : null;
                    out[kk] = { min: (mn === null || mn === undefined) ? null : Number(mn), max: (mx === null || mx === undefined) ? null : Number(mx) };
                }
                return out;
            }

            // Merge without shrinking: keep extremes across snapshot + runtime
            let changed = false;
            const out = { ...(prev || {}) };
            for (const [k, s] of Object.entries(incoming)) {
                const kk = normalizeKey(k);
                const mn = (s && s.min !== undefined) ? s.min : null;
                const mx = (s && s.max !== undefined) ? s.max : null;

                const prevEntry = out[kk] || { min: null, max: null };
                const nextMin = pickMin(prevEntry.min, mn);
                const nextMax = pickMax(prevEntry.max, mx);

                if (!out[kk] || nextMin !== prevEntry.min || nextMax !== prevEntry.max) {
                    out[kk] = { min: nextMin, max: nextMax };
                    changed = true;
                }
            }
            return changed ? out : prev;
        });
    }
}
    } catch (e) {
        console.warn("[cache_api] fetch failed:", e);
    }
};

const fetchHistory = async () => {
        try {
            await fetchCacheApiSnapshot(true);
            // 0) Seed r√°pido desde cache local (evita dashboard "en blanco" al cargar)
            if (!historyData || historyData.length === 0) {
                try {
                    const cached = localStorage.getItem(HISTORY_CACHE_KEY);
                    if (cached) {
                        const parsed = JSON.parse(cached);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            const cachedRows = parsed.map(r => normalizeRow(r));
                            setHistoryData(cachedRows);
                            setLastData(cachedRows[cachedRows.length - 1]);
                            if (chartConfig.timeRange === 'Ahora') {
                                setLiveData(cachedRows.slice(-LIVE_PRELOAD_LIMIT));
                            }
                            // Cargar sparkline history con el cache (best-effort)
                            const todayStart = cachedRows[0].timestamp || null;
                            CONFIG.dashboard.widgets.forEach(w => {
                                if (w.showSparkline || w.type === 'gauge' || w.showMinMax) {
                                    const wk = normalizeKey(w.key);
                                    const hDataBuffer = cachedRows.map(d => getVal(d, wk)).filter(v => v !== undefined && v !== null && v !== '--');
                                    const hDataToday = (todayStart !== null)
                                        ? cachedRows.filter(d => (d.timestamp || d.ts_iso) >= todayStart).map(d => getVal(d, wk)).filter(v => v !== undefined && v !== null && v !== '--')
                                        : [];
                                    try { SparklineEngine.setHistory(w.id, wk, hDataBuffer, w.min, w.max, hDataToday); } catch (e) {}
                                }
                            });
                        }
                    }
                } catch (e) {
                    // ignore cache errors
                }
            }

            const url = new URL(BASE_URL + '/api/data', window.location.origin);
            url.searchParams.append('limit', String(HISTORY_PRELOAD_LIMIT));
            const res = await fetch(url);
            if (!res.ok) return;
            const raw = await res.json();
            const fullHistory = Array.isArray(raw) ? raw.map(r => normalizeRow(r)) : [];

            // 1) Guardar cache acotado
            try {
                const slice = fullHistory.slice(-HISTORY_CACHE_LIMIT);
                localStorage.setItem(HISTORY_CACHE_KEY, JSON.stringify(slice));
            } catch (e) {
                // ignore
            }
            // Mantener el schema actual (array de filas normalizadas)
            setHistoryData(fullHistory);
            // Seed inicial: si hay hist√≥rico, mostrar el √∫ltimo valor (flat)
            if (fullHistory.length > 0) {
                const last = fullHistory[fullHistory.length - 1];
                setLastData(last);
            }
            // Cargar historial en los Sparklines y estad√≠sticas usando fullHistory
            const todayStart = fullHistory.length > 0 ? (fullHistory[0].timestamp || null) : null;
            CONFIG.dashboard.widgets.forEach(w => {
                if (w.showSparkline || w.type === 'gauge' || w.showMinMax) {
                    const wk = normalizeKey(w.key);
                    const hDataBuffer = fullHistory.map(d => getVal(d, wk)).filter(v => v !== undefined && v !== null && v !== '--');
                    const hDataToday = (todayStart !== null)
                        ? fullHistory.filter(d => (d.timestamp || d.ts_iso) >= todayStart).map(d => getVal(d, wk)).filter(v => v !== undefined && v !== null && v !== '--')
                        : [];
                    try {
                        SparklineEngine.setHistory(w.id, wk, hDataBuffer, w.min, w.max, hDataToday);
                    } catch (e) {
                        console.warn('SparklineEngine.setHistory fall√≥ para', w.id, e);
                    }
                }
            });
            // Si estamos en modo LIVE, inicializar liveData con los √∫ltimos puntos
            if (chartConfig.timeRange === 'Ahora') {
                const lastLive = fullHistory.slice(-LIVE_PRELOAD_LIMIT);
                setLiveData(lastLive);
            }

            // Precargar series server-side para Sparklines (historial profundo)
            await preloadSparklineHistory();
        } catch(e) { console.error("Error historial:", e); }
    };
    const fetchUpdate = async () => {
        try {
            await fetchCacheApiSnapshot(false);
            const res = await fetch(BASE_URL + '/api/last');
            if (!res.ok) throw new Error("API Offline");
            
            const raw = await res.json();
            // Nuevo: normalizar live a flat sin kv.
            const flat = normalizeRow(raw);
            const normalizedLive = flat;
            // Validar que la data es real
            const hasData = flat && flat.timestamp && flat.timestamp !== '--';
            if (hasData) {
                const hardwareTs = new Date(flat.timestamp).getTime();
                const isNewData = flat.timestamp !== (lastData && lastData.timestamp);
                if (isNewData) {
                    // --- NUEVA TELEMETR√çA DETECTADA ---
                    if (lastPacketTime > 0) {
                        const rawDelta = Math.abs(hardwareTs - lastPacketTime);
                        // Media M√≥vil para suavizar Jitter y Techo de 10 min
                        const newDelta = Math.min(600000, (currentDelta * 0.6) + (rawDelta * 0.4));
                        setCurrentDelta(newDelta);
                        setIsLearning(false);
                    }
                    
                    setLastPacketTime(hardwareTs);
                    setLastArrivalLocal(Date.now());
                    // Mantener flat para compat visual dentro del template
                    setLastData(flat);
	                    // Forzar refresco de sparklines en cada paquete nuevo
	                    setSparkTick(t => t + 1);
                    // Sincronizaci√≥n de Estado Deseado
                    setPendingCommands(prev => {
                        const next = { ...prev };
                        let changed = false;
                        Object.keys(next).forEach(key => {
                            const realVal = flat[key];
                            const desiredVal = next[key].value;
                            const isMatch = (String(realVal) === String(desiredVal)) || 
                                          (realVal === 1 && desiredVal === true) || 
                                          (realVal === 0 && desiredVal === false) ||
                                          (realVal === "ON" && desiredVal === true) ||
                                          (realVal === "OFF" && desiredVal === false);
                            if (isMatch || (Date.now() - next[key].ts > 30000)) {
                                delete next[key];
                                changed = true;
                            }
                        });
                        return changed ? next : prev;
                    });
                    // Actualizaci√≥n Centralizada del Motor (usar normalizedLive.kv para valores)
                    CONFIG.dashboard.widgets.forEach(w => {
    const wk = normKey(w.key);
    const rawVal = getVal(flat, wk);
    SparklineEngine.update(w.id, wk, rawVal, w.min || 0, w.max || 100, flat.timestamp);
});
                    // Estado reportado por el hardware
	                    const connWidget = CONFIG.dashboard.widgets.find(w => w.type === 'connection');
	                    // Prioridad: statusKey expl√≠cito > key del widget > fallback hist√≥rico
	                    const statusKey = connWidget?.statusKey || connWidget?.key || 'gsm_stored_state';
	                    const rawReported = getVal(flat, statusKey);
                    let reportedState = (rawReported === undefined || rawReported === null) ? "ONLINE" : String(rawReported);
                    // Si el valor reportado es un n√∫mero largo (timestamp o ID), no mostrarlo como estado.
                    // Ej: 1073470396 suele ser un timestamp/ID accidentalmente mapeado.
                    if (/^d{6,}$/.test(reportedState)) {
                        reportedState = "ONLINE";
                    }
                    reportedState = reportedState.toUpperCase();
                    
                    if (reportedState === "ONLINE" || reportedState === "REG_OK") {
                        setConnStatus("SISTEMA ONLINE");
                        setConnColor("#10b981");
                    } else if (reportedState === "BUSCANDO") {
                        setConnStatus("BUSCANDO RED...");
                        setConnColor("#f59e0b");
                    } else if (reportedState === "OFFLINE") {
                        setConnStatus("ERROR: SIN CHIP");
                        setConnColor("#ef4444");
                    } else {
                        setConnStatus(reportedState);
                        setConnColor("#10b981");
                    }
                    if (chartConfig.timeRange === 'Ahora') {
                        setLiveData(prev => {
                            const next = [...prev, flat];
                            return next.length > LIVE_MAX_POINTS ? next.slice(-LIVE_MAX_POINTS) : next;
                        });
                    }
                } else {
                    // --- NO HAY DATOS NUEVOS, EVALUAR TIEMPO ---
                    const elapsed = Date.now() - lastArrivalLocal;
                    // Margen din√°mico: Delta + 2s (o 10s si estamos aprendiendo)
                    const threshold = currentDelta + (isLearning ? 10000 : 2000);
                    if (elapsed > (threshold * 2)) {
                        setConnStatus("EQUIPO OFFLINE");
                        setConnColor("#ef4444"); // Rojo
                    } else if (elapsed > threshold) {
                        setConnStatus("CONECTANDO...");
                        setConnColor("#f59e0b"); // Naranja
                    }
                }
            } else {
                setConnStatus("SIN DATOS");
                setConnColor("#ef4444"); // Rojo
            }
        } catch(e) {
            setConnStatus("API OFFLINE");
            setConnColor("#ef4444");
            console.error("Error actualizaci√≥n:", e);
        }
        try {
            const res = await fetch(BASE_URL + '/api/control_state');
            if (res.ok) {
                setControlState(await res.json());
            }
        } catch(e) { console.warn("Fallo Controles:", e); }
    };

// --- Extend widget min/max with live values (only updates if live exceeds snapshot extremes) ---
const minMaxKeys = useMemo(() => {
    try {
        return (CONFIG.dashboard.widgets || [])
            .filter(w => w && w.showMinMax)
            .map(w => normalizeKey(w.key))
            .filter(Boolean);
    } catch {
        return [];
    }
}, []);

useEffect(() => {
    if (!lastData) return;
    if (!dayStatsLive) return;

    setDayStatsLive(prev => {
        let changed = false;
        const out = { ...(prev || {}) };

        for (const k of minMaxKeys) {
            // lastData ya viene normalizado (sin kv.)
            const raw = lastData[k];
            const v = (typeof raw === "string") ? Number(raw) : Number(raw);
            if (!isValidForMinMax(k, v)) continue;

            const prevEntry = out[k] || { min: null, max: null };
            const nextMin = pickMin(prevEntry.min, v);
            const nextMax = pickMax(prevEntry.max, v);

            if (!out[k] || nextMin !== prevEntry.min || nextMax !== prevEntry.max) {
                out[k] = { min: nextMin, max: nextMax };
                changed = true;
            }
        }

        return changed ? out : prev;
    });
}, [lastData, minMaxKeys]);

	// Poll de alertas (separado del loop live para no spamear el Bridge)
	const fetchAlerts = async () => {
		try {
			const u = new URL(BASE_URL + '/api/alerts', window.location.origin);
			u.searchParams.set('limit', '200');
			const res = await fetch(u);
			if (!res.ok) return;
			const js = await res.json();
			const arr = Array.isArray(js) ? js : [];
			const normalized = arr.map(a => {
				const ms = getAlertMs(a);
				const timestamp = a.ts_iso || a.timestamp || (ms ? new Date(ms).toISOString() : new Date().toISOString());
				return { ...a, timestamp, __ts_ms: ms };
			}).filter(a => (a.__ts_ms || 0) > alertsSeenUntilMs);
			setAlerts(normalized);
		} catch(e) { console.warn("Fallo Alertas:", e); }
	};

	useEffect(() => {
		let mounted = true;
		const run = async () => {
			if (!mounted) return;
			await fetchAlerts();
		};
		run();
		const id = setInterval(() => { fetchAlerts(); }, ALERTS_POLL_MS);
		return () => { mounted = false; clearInterval(id); };
	}, [BASE_URL, alertsSeenUntilMs]);
    const displayData = useMemo(() => {
        const isLive = chartConfig.timeRange === 'Ahora';
        let filtered = isLive ? liveData : seriesData;
        if (!isLive) {
            // 2. Filtro Horario (D√≠a / Noche)
            if (chartConfig.filter === 'day') {
                filtered = filtered.filter(d => {
                    const h = new Date(d.timestamp).getHours();
                    return h >= 7 && h < 19;
                });
            } else if (chartConfig.filter === 'night') {
                filtered = filtered.filter(d => {
                    const h = new Date(d.timestamp).getHours();
                    return h < 7 || h >= 19;
                });
            }
        }
        const finalData = Array.isArray(filtered) ? filtered : [];
        return finalData.map(d => {
            if (!d) return { t: '', v: null, v2: null, fullTimestamp: null };
            const ts = new Date(d.timestamp);
            const label = isLive 
                ? ts.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
                : ts.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' }) + ' ' + ts.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            
            const y1 = normKey(chartConfig.primaryY);
            const y2 = chartConfig.secondaryY ? normKey(chartConfig.secondaryY) : null;
            const v1Raw = parseFloat(getVal(d, y1));
            const v2Raw = y2 ? parseFloat(getVal(d, y2)) : NaN;
            // BLINDAJE PUNTO 4: Chart.js tratar√° null como un hueco en la l√≠nea
            const v1 = v1Raw === -50.0 ? null : v1Raw;
            const v2 = v2Raw === -50.0 ? null : v2Raw;
            return {
                t: label,
                v: v1,
                v2: v2,
                fullTimestamp: d.timestamp
            };
        }); // No filtramos, para permitir huecos (null) en Chart.js
    }, [chartConfig, seriesData, liveData]);
    const sendControl = async (key, val) => {
        try {
            // Marcar como pendiente de inmediato
            setPendingCommands(prev => ({ 
                ...prev, 
                [key]: { value: val, ts: Date.now() } 
            }));
            const res = await fetch(BASE_URL + '/api/control_state', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ [key]: val })
            });
            if (res.ok) {
                setControlState(prev => ({ ...prev, [key]: val }));
            }
        } catch(e) { console.error("Error env√≠o control:", e); }
    };
    useEffect(() => {
        let mounted = true;
        let intervalId = null;
        const startLoop = async () => {
            try {
                // Asegurarnos de cargar historial antes de hacer la primera actualizaci√≥n live
                await fetchHistory();
            } catch (e) {
                console.warn('fetchHistory fall√≥ en arranque', e);
            }
            if (!mounted) return;
            try {
                await fetchUpdate();
            } catch (e) {
                console.warn('fetchUpdate inicial fall√≥', e);
            }
            intervalId = setInterval(fetchUpdate, (CONFIG.refreshInterval ?? 1000));
        };
        startLoop();
        return () => {
            mounted = false;
            if (intervalId) clearInterval(intervalId);
        };
    }, []);
    useEffect(() => {
        setTimeout(() => { if(window.lucide) lucide.createIcons(); }, 100);
    }, [activeTabId]);
    const activeVarLabel = useMemo(() => {
        return CONFIG.labels[chartConfig.primaryY] || chartConfig.primaryY;
    }, [chartConfig.primaryY]);
    return (
        <div className="adtec-dashboard-root">
            <div className="tabs-nav">
                {CONFIG.dashboard.tabs.map(t => (
                    <div 
                        key={t.id} 
                        className={"tab-btn " + (activeTabId === t.id ? "active" : "")} 
                        onClick={() => setActiveTabId(t.id)}
                        style={{ position: 'relative' }}
                    >
                        {t.icon && t.icon.length > 2 ? (
                            <i data-lucide={t.icon}></i>
                        ) : (
                            <span>{t.icon || 'üìÑ'}</span>
                        )} {t.name}
                        {t.type === 'alerts' && alerts.length > 0 && (
                            <span className="alert-badge">{alerts.length}</span>
                        )}
                    </div>
                ))}
            </div>
            <div className="adtec-card" style={{ width: currentTab.width + 'px', minHeight: currentTab.height + 'px', margin: '0 auto' }}>
                {currentTab.type !== 'charts' && (
                    <div className="card-header">
                        <div className="logo-section">
                            <div className="logo-icon"><div className="logo-icon-inner">ADTEC</div></div>
                            <span className="card-title">{currentTab.title}</span>
                        </div>
                        {currentTab.type === 'control' && (
                            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', background: 'rgba(255,255,255,0.05)', padding: '5px 12px', borderRadius: '20px', border: '1px solid rgba(148,163,184,0.1)' }}>
                                <span style={{ fontSize: '9px', fontWeight: 700, color: controlState.manual ? 'var(--adtec-accent)' : '#9ca3af' }}>
                                    {controlState.manual ? 'MANUAL' : 'AUTO'}
                                </span>
                                <label className="switch" style={{ transform: 'scale(0.7)' }}>
                                    <input type="checkbox" checked={!!controlState.manual} onChange={(e) => sendControl('manual', e.target.checked)} />
                                    <span className="slider"></span>
                                </label>
                            </div>
                        )}
                        <div style={{ fontSize: '11px', fontWeight: '800', color: connColor }}>{connStatus}</div>
                    </div>
                )}
                <div className={currentTab.type === 'charts' ? "card-body-flat" : "card-body"}>
                    {currentTab.type !== 'charts' && <div className="grid-bg"></div>}
                    
                    {currentTab.type === 'alerts' ? (
                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', padding: '25px', overflowY: 'auto' }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '25px', borderBottom: '1px solid rgba(148, 163, 184, 0.1)', paddingBottom: '15px' }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                    <div className="logo-icon" style={{ width: 30, height: 30, borderRadius: 8, background: '#ef4444', boxShadow: '0 0 15px rgba(239, 68, 68, 0.4)' }}>
                                        <div className="logo-icon-inner" style={{ fontSize: 9 }}>ADTEC</div>
                                    </div>
                                    <h2 style={{ margin: 0, fontSize: '18px', color: '#f8fafc' }}>Centro de Notificaciones</h2>
                                </div>
							<button 
								onClick={() => {
									if (confirm('¬øMarcar todas las alertas actuales como le√≠das?')) {
										const msList = (alerts || []).map(getAlertMs).filter(n => typeof n === 'number' && isFinite(n));
										const maxMs = Math.max(Date.now(), ...(msList.length ? msList : [0]));
										setSeenUntil(maxMs);
										setAlerts([]);
									}
								}}
                                    style={{ padding: '6px 15px', background: 'rgba(239, 68, 68, 0.1)', border: '1px solid #ef4444', borderRadius: '6px', color: '#ef4444', cursor: 'pointer', fontWeight: 'bold', fontSize: '11px' }}
                                >
								MARCAR COMO LE√çDAS
                                </button>
                            </div>
                            {alerts.length === 0 ? (
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', opacity: 0.5 }}>
                                    <span style={{ fontSize: '48px', marginBottom: '15px' }}>üü¢</span>
                                    <p style={{ fontSize: '14px', fontWeight: '600' }}>Sistema en estado √≥ptimo</p>
                                    <p style={{ fontSize: '12px' }}>No hay alertas registradas en este momento.</p>
                                </div>
                            ) : (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                                    {[...alerts].reverse().map((a, i) => (
                                        <div key={i} className="alert-card-item">
                                            <div className="alert-card-side"></div>
                                            <div className="alert-card-content">
                                                <div className="alert-card-header">
                                                    <span className="alert-card-tag">CR√çTICO</span>
                                                    <span className="alert-card-time">{new Date(a.timestamp).toLocaleString('es-ES')}</span>
                                                </div>
                                                <div className="alert-card-msg">{a.msg}</div>
                                                <div className="alert-card-detail">
                                                    {Object.entries(a).map(([key, value]) => (
                                                        <div key={key} style={{ fontSize: '10px', color: 'var(--text-muted)' }}>
                                                            {key}: <b>{String(value)}</b>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    ) : currentTab.type === 'charts' ? (
                        <div style={{ flex: 1, position: 'relative', overflowY: 'auto', padding: 25, display: 'flex', flexDirection: 'column' }}>
                            {(!CONFIG.dashboard.variables || CONFIG.dashboard.variables.length === 0) ? (
                                <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', opacity: 0.5 }}>
                                    <p>No hay variables disponibles para graficar.</p>
                                </div>
                            ) : (
                                <>
                                    <div style={{ borderBottom: '1px solid rgba(148, 163, 184, 0.2)', paddingBottom: 15, marginBottom: 20, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
                                    <div className="logo-icon" style={{ width: 30, height: 30, borderRadius: 8, boxShadow: '0 0 15px rgba(250, 204, 21, 0.4)' }}>
                                        <div className="logo-icon-inner" style={{ fontSize: 9 }}>ADTEC</div>
                                    </div>
                                    <h2 style={{ margin: 0, fontSize: 18, color: '#f8fafc', letterSpacing: '0.05em' }}>{currentTab.title}</h2>
                                    <div style={{ marginLeft: 10, padding: '2px 8px', background: '#ef4444', color: 'white', fontSize: 9, borderRadius: 4, fontWeight: 800, display: 'flex', alignItems: 'center', gap: 5 }}>
                                        <span style={{ width: 4, height: 4, background: 'white', borderRadius: '50%', display: 'inline-block' }}></span> LIVE
                                    </div>
                                </div>
                                <div style={{ display: 'flex', gap: 8 }}>
                                    <button 
                                        onClick={() => setChartConfig(prev => ({
                                            ...prev,
                                            primaryY: (CONFIG.dashboard.variables && CONFIG.dashboard.variables[0]?.key) || '',
                                            secondaryY: '',
                                            filter: 'all',
                                            fromDate: '',
                                            toDate: '',
                                            timeRange: 'Ahora'
                                        }))}
                                        style={{ padding: '5px 10px', borderRadius: 6, background: 'rgba(255,255,255,0.05)', color: '#9ca3af', border: '1px solid rgba(148,163,184,0.1)', cursor: 'pointer', fontSize: 10 }}
                                    >Reset filtros</button>
                                    <a href={BASE_URL + "/api/download/xlsx?channel=ingreso"} style={{ padding: '5px 10px', borderRadius: 6, background: 'var(--adtec-accent)', color: 'black', border: 'none', cursor: 'pointer', fontWeight: 700, fontSize: 10, textDecoration: 'none' }}>XLSX</a>
                                </div>
                            </div>
                            <div style={{ background: 'rgba(255,255,255,0.03)', padding: 15, borderRadius: 12, border: '1px solid rgba(148, 163, 184, 0.1)', marginBottom: 20 }}>
                                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: 15, marginBottom: 15 }}>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#38bdf8', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 800 }}>Eje Y Principal</label>
                                        <select 
                                            value={chartConfig.primaryY} 
                                            onChange={(e) => setChartConfig(prev => ({ ...prev, primaryY: e.target.value }))}
                                            style={{ width: '100%', padding: '8px', background: '#1e293b', color: '#38bdf8', border: '1px solid rgba(56, 189, 248, 0.4)', borderRadius: 6, fontSize: 12, fontWeight: 'bold', boxShadow: '0 0 10px rgba(56, 189, 248, 0.1)' }}
                                        >
                                            {(CONFIG.dashboard.variables || []).map(v => <option key={v.key} value={v.key} style={{ color: 'white' }}>{v.label}</option>)}
                                        </select>
                                    </div>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#a855f7', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 800 }}>Eje Y Secundario</label>
                                        <select 
                                            value={chartConfig.secondaryY} 
                                            onChange={(e) => setChartConfig(prev => ({ ...prev, secondaryY: e.target.value }))}
                                            style={{ width: '100%', padding: '8px', background: '#1e293b', color: '#a855f7', border: '1px solid rgba(168, 85, 247, 0.4)', borderRadius: 6, fontSize: 12, fontWeight: 'bold', boxShadow: '0 0 10px rgba(168, 85, 247, 0.1)' }}
                                        >
                                            <option value="" style={{ color: 'white' }}>(sin eje secundario)</option>
                                            {(CONFIG.dashboard.variables || []).map(v => <option key={v.key} value={v.key} style={{ color: 'white' }}>{v.label}</option>)}
                                        </select>
                                    </div>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#9ca3af', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 600 }}>Vista Horaria</label>
                                        <div style={{ display: 'flex', gap: 5 }}>
                                            {[
                                                { id: 'all', label: 'Todo', icon: 'üåì' },
                                                { id: 'day', label: 'D√≠a', icon: '‚òÄÔ∏è' },
                                                { id: 'night', label: 'Noche', icon: 'üåô' }
                                            ].map(f => (
                                                <button
                                                    key={f.id}
                                                    disabled={chartConfig.timeRange === 'Ahora'}
                                                    onClick={() => setChartConfig(prev => ({ ...prev, filter: f.id }))}
                                                    style={{ 
                                                        flex: 1,
                                                        padding: '8px', 
                                                        borderRadius: 6, 
                                                        border: "1px solid " + (chartConfig.filter === f.id ? 'var(--adtec-accent)' : 'rgba(148,163,184,0.1)'),
                                                        background: chartConfig.filter === f.id ? 'rgba(56,189,248,0.1)' : '#1e293b',
                                                        color: chartConfig.filter === f.id ? 'var(--adtec-accent)' : '#9ca3af',
                                                        fontSize: 11,
                                                        cursor: 'pointer',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        gap: 4,
                                                        opacity: chartConfig.timeRange === 'Ahora' ? 0.5 : 1
                                                    }}
                                                >
                                                    {f.icon} {f.label}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1.5fr', gap: 15 }}>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#9ca3af', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 600 }}>Desde</label>
                                        <input 
                                            type="datetime-local" 
                                            disabled={chartConfig.timeRange !== 'Rango'}
                                            value={chartConfig.fromDate || ''}
                                            onChange={(e) => setChartConfig(prev => ({ ...prev, fromDate: e.target.value }))}
                                            style={{ width: '100%', padding: '8px', background: '#1e293b', color: 'white', border: '1px solid rgba(148, 163, 184, 0.2)', borderRadius: 6, fontSize: 11, opacity: chartConfig.timeRange !== 'Rango' ? 0.5 : 1 }}
                                        />
                                    </div>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#9ca3af', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 600 }}>Hasta</label>
                                        <input 
                                            type="datetime-local" 
                                            disabled={chartConfig.timeRange !== 'Rango'}
                                            value={chartConfig.toDate || ''}
                                            onChange={(e) => setChartConfig(prev => ({ ...prev, toDate: e.target.value }))}
                                            style={{ width: '100%', padding: '8px', background: '#1e293b', color: 'white', border: '1px solid rgba(148, 163, 184, 0.2)', borderRadius: 6, fontSize: 11, opacity: chartConfig.timeRange !== 'Rango' ? 0.5 : 1 }}
                                        />
                                    </div>
                                    <div className="form-group">
                                        <label style={{ fontSize: 10, color: '#9ca3af', textTransform: 'uppercase', marginBottom: 5, display: 'block', fontWeight: 600 }}>Rango R√°pido</label>
                                        <div style={{ display: 'flex', gap: 5 }}>
                                            {[
                                                { id: 'Ahora', label: 'LIVE', icon: 'üì°' },
                                                { id: '24h', label: '24H', icon: 'üìÖ' },
                                                { id: '7d', label: '7D', icon: 'üóìÔ∏è' },
                                                { id: 'Rango', label: 'RANGO', icon: '‚ôæÔ∏è' }
                                            ].map(r => (
                                                <button
                                                    key={r.id}
                                                    onClick={() => setChartConfig(prev => ({ ...prev, timeRange: r.id }))}
                                                    style={{ 
                                                        flex: 1,
                                                        padding: '8px 4px', 
                                                        borderRadius: 6, 
                                                        border: "1px solid " + (chartConfig.timeRange === r.id ? 'var(--adtec-accent)' : 'rgba(148,163,184,0.1)'),
                                                        background: chartConfig.timeRange === r.id ? 'rgba(56,189,248,0.1)' : '#1e293b',
                                                        color: chartConfig.timeRange === r.id ? 'var(--adtec-accent)' : '#9ca3af',
                                                        fontSize: 10,
                                                        fontWeight: 700,
                                                        cursor: 'pointer'
                                                    }}
                                                >
                                                    {r.icon} {r.label}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
	                            {/* Barra informativa: primer/√∫ltimo timestamp del modo actual */}
	                            <div style={{ marginTop: 10, fontSize: 12, opacity: 0.9, display: 'flex', gap: 14, flexWrap: 'wrap' }}>
	                                <div><strong>Desde:</strong> {chartConfig.fromDate || '--'}</div>
	                                <div><strong>Hasta:</strong> {chartConfig.toDate || '--'}</div>
	                            </div>
                            <div style={{ height: '400px', background: 'rgba(0,0,0,0.2)', borderRadius: 12, padding: 15 }}>
                                <DashboardChart 
                                    widget={{ label: activeVarLabel }} 
                                    dataHistory={displayData} 
                                    chartConfig={chartConfig}
                                />
                            </div>
                                </>
                            )}
                        </div>
                    ) : (
                        <div className="widgets-area">
                            {CONFIG.dashboard.widgets.filter(w => String(w.tabId) === String(activeTabId)).map(w => {
                            const valStr = getWidgetValue(w.key);
                            const val = parseFloat(valStr);
                            const style = { left: w.x, top: w.y, width: w.w, height: w.h, position: 'absolute' };
                            if (w.type === 'label') {
                                return (
                                    <div key={w.id} className="adtec-label-widget" style={{ ...style, color: w.color || 'white', fontSize: w.fontSize || 14, fontWeight: 'bold' }}>
                                        {w.label}
                                    </div>
                                );
                            }
                            if (w.type === 'chart' || w.type === 'summary-chart') {
                                return (
                                    <div key={w.id} className="adtec-status-item" style={style}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 5, gap: 8 }}>
                                            <h3 style={{ flex: 1, wordBreak: 'break-word', lineHeight: '1.1' }}>{w.label}</h3>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, flexShrink: 0 }}>
                                                {!w.hideKey && <span style={{ fontSize: '9px', opacity: 0.4, color: '#9ca3af' }}>{w.key}</span>}
                                                <a href={BASE_URL + "/api/download/xlsx?channel=ingreso"} title="Descargar XLSX" style={{ color: '#94a3b8', textDecoration: 'none' }}>
                                                    <i data-lucide="download" style={{ width: 14, height: 14 }}></i>
                                                </a>
                                                <span style={{ fontSize: '14px', fontWeight: '800', color: 'var(--adtec-accent)' }}>{valStr}</span>
                                            </div>
                                        </div>
                                        <div style={{ flex: 1, position: 'relative', minHeight: 0 }}>
                                            <DashboardChart widget={w} dataHistory={
                                                historyData && historyData.length > 0 ? historyData.map(d => {
                                                    const ts = new Date(d.timestamp);
                                                    const label = ts.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' }) + ' ' + ts.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
                                                    const raw = getVal(d, normKey(w.key));
                                                    const parsed = parseFloat(raw);
                                                    const v = isNaN(parsed) ? null : (parsed === -50.0 ? null : parsed);
                                                    return { t: label, v: v, v2: null, fullTimestamp: d.timestamp };
                                                }) : []
                                            } chartConfig={{ primaryY: w.key }} />
                                        </div>
                                    </div>
                                );
                            }
                            return (
                                <div key={w.id} className="adtec-status-item" style={style}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 8 }}>
                                            <h3 style={{ flex: 1, wordBreak: 'break-word', lineHeight: '1.1' }}>{w.label}</h3>
                                        {!w.hideKey && <span style={{ fontSize: '9px', opacity: 0.4, color: '#9ca3af', flexShrink: 0 }}>{w.key}</span>}
                                    </div>
                                    {w.type === 'gauge' && (() => {
                                        const numVal = isNaN(parseFloat(valStr)) ? (w.min || 0) : parseFloat(valStr);
                                        const min = w.min || 0;
                                        const max = w.max || 100;
                                        const pct = Math.max(0, Math.min(100, ((numVal - min) / (Math.max(1, max - min))) * 100));
                                        
                                        // M√≠n/M√°x del d√≠a (separado del sparkline): cache_api.snapshot.day_stats
const wk = normalizeKey(w.key);
const ds = (dayStatsLive && dayStatsLive[wk]) ? dayStatsLive[wk] : ((cacheApiSnapshot && cacheApiSnapshot.day_stats) ? cacheApiSnapshot.day_stats[wk] : null);
const minDay = (ds && ds.min !== null && ds.min !== undefined) ? formatValue(ds.min, w.format, "") : "--";
const maxDay = (ds && ds.max !== null && ds.max !== undefined) ? formatValue(ds.max, w.format, "") : "--";
                                        return (
                                            <>
                                                <div className="adtec-status-value" style={{ textAlign: 'center' }}>
                                                    {valStr.replace(w.unit || '', '')} 
                                                    <span style={{ fontSize: '12px', fontWeight: 400, opacity: 0.6 }}>{w.unit}</span>
                                                </div>
                                                {w.showMinMax && (
                                                    <div style={{ fontSize: '10px', color: '#94a3b8', textAlign: 'center', marginTop: '-2px', marginBottom: '10px', fontWeight: 500 }}>
                                                        M√≠n: {minDay} {w.unit} ¬∑ M√°x: {maxDay} {w.unit}
                                                    </div>
                                                )}
                                            {(w.showBar ?? true) && (
                                                <div className="adtec-temp-bar" style={{ background: getGradientByType('TEMP', 0.25, w.inverted), marginTop: w.showMinMax ? '0px' : '5px' }}>
                                                    <div 
                                                        className="adtec-temp-bar-fill" 
                                                        style={{ 
                                                            width: pct + "%",
                                                            background: getGradientByType('TEMP', 1, w.inverted),
                                                            backgroundSize: (100 / (Math.max(1, pct) / 100)) + "% 100%",
                                                            boxShadow: "0 0 10px " + getGaugeColor(numVal, w.key) + "66"
                                                        }} 
                                                    />
                                                </div>
                                            )}
                                            {w.showSparkline && (
                                                <Sparkline 
                                                    id={w.id} 
                                                    variableKey={w.key} 
                                                    min={w.min} 
                                                    max={w.max} 
                                                    inverted={w.inverted} 
                                                    // Evitar que el fallback numVal ensucie el gr√°fico al inicio
                                                    value={valStr === '--' ? undefined : numVal} 
                                                    showShadow={w.sparklineShadow}
                                                    historyTick={sparkTick}
                                                />
                                            )}
                                        </>
                                    );
                                    })()}
                                    {w.type === 'indicator' && (() => {
                                        const isOn = valStr === 'ON' || valStr === 'ACTIVO' || valStr === 'TRUE';
                                        return (
                                            <div className={"adtec-status-chip " + (isOn ? "on" : "off")} style={{ marginTop: 'auto', alignSelf: 'flex-start' }}>
                                                <span className={"adtec-status-dot " + (isOn ? "on" : "off")} />
                                                <span>{isOn ? 'ACTIVO' : 'INACTIVO'}</span>
                                            </div>
                                        );
                                    })()}
                                    {w.type === 'control-relay' && (() => {
                                        const isOn = valStr === 'ON' || valStr === 'ACTIVO' || valStr === 'TRUE';
                                        const isManual = !!controlState.manual;
                                        const pending = pendingCommands[w.target];
                                        const isPending = pending !== undefined;
                                        return (
                                            <>
                                                <div className={"adtec-status-chip " + (isOn ? "on" : "off")} style={{ marginBottom: 10, alignSelf: 'flex-start' }}>
                                                    <span className={"adtec-status-dot " + (isOn ? "on" : "off")} />
                                                    <span>{isOn ? 'ACTIVO' : 'INACTIVO'}</span>
                                                </div>
                                                <div style={{ display: 'flex', gap: '5px' }}>
                                                    <button 
                                                        className="vfd-btn start" 
                                                        disabled={!isManual} 
                                                        style={{ 
                                                            background: isOn ? '#10b981' : (pending?.value === true ? '#065f46' : undefined),
                                                            opacity: isManual ? 1 : 0.5,
                                                            cursor: isManual ? 'pointer' : 'not-allowed',
                                                            boxShadow: pending?.value === true ? '0 0 10px rgba(16, 185, 129, 0.4)' : 'none'
                                                        }} 
                                                        onClick={() => sendControl(w.target, true)}
                                                    >
                                                        {pending?.value === true ? '‚è≥ ON...' : 'ON'}
                                                    </button>
                                                    <button 
                                                        className="vfd-btn stop" 
                                                        disabled={!isManual} 
                                                        style={{ 
                                                            background: !isOn ? '#ef4444' : (pending?.value === false ? '#7f1d1d' : undefined),
                                                            opacity: isManual ? 1 : 0.5,
                                                            cursor: isManual ? 'pointer' : 'not-allowed',
                                                            boxShadow: pending?.value === false ? '0 0 10px rgba(239, 68, 68, 0.4)' : 'none'
                                                        }} 
                                                        onClick={() => sendControl(w.target, false)}
                                                    >
                                                        {pending?.value === false ? '‚è≥ OFF...' : 'OFF'}
                                                    </button>
                                                </div>
                                            </>
                                        );
                                    })()}
                                    {w.type === 'control-vfd' && (() => {
                                        const freq = parseFloat(controlState[w.target] || 0);
                                        const isOn = valStr === 'ON' || valStr === 'ACTIVO' || valStr === 'TRUE';
                                        const isManual = !!controlState.manual;
                                        const pending = pendingCommands[w.target + '_state'];
                                        return (
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: 15, marginTop: 5, alignItems: 'center', width: '100%' }}>
                                                <div className={"vfd-dial " + (isOn ? "on" : "")}>
                                                    <div className="vfd-dial-value">{freq.toFixed(1)}</div>
                                                    <div className="vfd-dial-unit">Hz</div>
                                                </div>
                                                <input 
                                                    type="range" min="0" max="60" step="0.5" 
                                                    value={freq}
                                                    disabled={!isManual}
                                                    style={{ width: '100%', accentColor: 'var(--adtec-accent)', opacity: isManual ? 1 : 0.5 }}
                                                    onChange={(e) => sendControl(w.target, parseFloat(e.target.value))}
                                                />
                                                <div style={{ display: 'flex', gap: '5px', width: '100%' }}>
                                                    <button 
                                                        className="vfd-btn start" 
                                                        disabled={!isManual} 
                                                        style={{ 
                                                            background: isOn ? '#10b981' : (pending?.value === true ? '#065f46' : undefined),
                                                            opacity: isManual ? 1 : 0.5,
                                                            cursor: isManual ? 'pointer' : 'not-allowed',
                                                            boxShadow: pending?.value === true ? '0 0 10px rgba(16, 185, 129, 0.4)' : 'none'
                                                        }} 
                                                        onClick={() => sendControl(w.target + '_state', true)}
                                                    >
                                                        {pending?.value === true ? '‚è≥ RUN...' : 'RUN'}
                                                    </button>
                                                    <button 
                                                        className="vfd-btn stop" 
                                                        disabled={!isManual} 
                                                        style={{ 
                                                            background: !isOn ? '#ef4444' : (pending?.value === false ? '#7f1d1d' : undefined),
                                                            opacity: isManual ? 1 : 0.5,
                                                            cursor: isManual ? 'pointer' : 'not-allowed',
                                                            boxShadow: pending?.value === false ? '0 0 10px rgba(239, 68, 68, 0.4)' : 'none'
                                                        }} 
                                                        onClick={() => sendControl(w.target + '_state', false)}
                                                    >
                                                        {pending?.value === false ? '‚è≥ STOP...' : 'STOP'}
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    })()}
                                    {w.type === 'connection' && (() => {
                                        const sigKey = w.signalKey || w.key;
                                        const sigVal = parseFloat(getWidgetValue(sigKey) || getWidgetValue('gsm_signal') || "0");
                                        const isSystemOnline = connStatus.includes("ONLINE") || connStatus.includes("CONECTANDO");
                                        
                                        return (
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '5px' }}>
                                                <div style={{ display: 'flex', gap: '2px', alignItems: 'flex-end', height: '20px' }}>
                                                    {[1, 2, 3, 4, 5].map(i => {
                                                        const threshold = i * 6; // Rango 0-31 CSQ (aprox 6 por barra)
                                                        const isBarActive = isSystemOnline && sigVal >= threshold;
                                                        return React.createElement('div', {
                                                            key: i,
                                                            style: {
                                                                width: '3px',
                                                                height: (i * 4) + 'px',
                                                                background: isBarActive ? 'var(--adtec-accent)' : 'rgba(255,255,255,0.1)',
                                                                borderRadius: '1px',
                                                                boxShadow: isBarActive ? '0 0 5px var(--adtec-accent)' : 'none'
                                                            }
                                                        });
                                                    })}
                                                </div>
                                                <div className="adtec-status-chip" style={{ margin: 0, background: connColor + '22', border: '1px solid ' + connColor + '44', color: connColor }}>
                                                    <span className="adtec-status-dot" style={{ background: connColor, boxShadow: '0 0 8px ' + connColor }} />
                                                    <span style={{ fontWeight: 800, fontSize: '10px' }}>{connStatus}</span>
                                                </div>
                                            </div>
                                        );
                                    })()}
                                    {w.type === 'datetime' && (() => {
	                                        const rawVal = getWidgetValue(w.key);
	                                        // No pegar la unidad a la fecha. La unidad (p.ej. "hs") va solo junto a la HORA.
	                                        const formatted = formatValue(rawVal === '--' ? new Date().toISOString() : rawVal, w.format || 'datetime_full', "");
                                        const parts = formatted.split('|');
                                        const displayTime = parts[0];
                                        const displayDate = parts[1] || '';
	                                        const timeUnit = (w.unit || '').trim();
                                        
                                        return (
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '5px' }}>
                                                <span style={{ fontSize: '20px' }}>‚è∞</span>
                                                <div>
	                                                    <div style={{ fontSize: '14px', color: 'var(--adtec-accent)', fontWeight: 800 }}>
	                                                        {displayTime}{timeUnit ? ' ' + timeUnit : ''}
	                                                    </div>
                                                    {displayDate && <div style={{ fontSize: '10px', color: '#9ca3af' }}>{displayDate}</div>}
                                                </div>
                                            </div>
                                        );
                                    })()}
                                    {w.type === 'text' && (() => {
                                        if (w.label.toLowerCase().includes('red') || w.label.toLowerCase().includes('estado')) {
                                            return (
                                                <div className="adtec-status-chip" style={{ marginTop: 'auto', alignSelf: 'flex-start', background: connColor + '22', border: '1px solid ' + connColor + '44', color: connColor }}>
                                                    <span className="adtec-status-dot" style={{ background: connColor, boxShadow: '0 0 8px ' + connColor }} />
                                                    <span style={{ fontWeight: 800, fontSize: '10px' }}>{connStatus}</span>
                                                </div>
                                            );
                                        }
                                        // M√≠n/M√°x del d√≠a (separado del sparkline): cache_api.snapshot.day_stats
const wk = normalizeKey(w.key);
const ds = (dayStatsLive && dayStatsLive[wk]) ? dayStatsLive[wk] : ((cacheApiSnapshot && cacheApiSnapshot.day_stats) ? cacheApiSnapshot.day_stats[wk] : null);
const minDay = (ds && ds.min !== null && ds.min !== undefined) ? formatValue(ds.min, w.format, "") : "--";
const maxDay = (ds && ds.max !== null && ds.max !== undefined) ? formatValue(ds.max, w.format, "") : "--";
                                        return (
                                            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%' }}>
                                                <div className="adtec-status-value" style={{ textAlign: 'center' }}>
                                                    {valStr.replace(w.unit || '', '')} 
                                                    <span style={{ fontSize: '12px', fontWeight: 400, opacity: 0.6 }}>{w.unit}</span>
                                                </div>
                                                {w.showMinMax && (
                                                    <div style={{ fontSize: '10px', color: '#94a3b8', textAlign: 'center', marginTop: '-2px', fontWeight: 500 }}>
                                                        M√≠n: {minDay} {w.unit} ¬∑ M√°x: {maxDay} {w.unit}
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })()}
                                    {w.type === 'location' && (() => {
                                        const coords = getWidgetValue(w.key);
                                        const city = w.statusKey ? getWidgetValue(w.statusKey) : '';
                                        return (
                                            <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 5, color: '#9ca3af' }}>
                                                <span style={{ fontSize: 20 }}>üìç</span>
                                            <div>
                                            <div style={{ fontSize: 12, color: 'white', fontWeight: 600 }}>{city || 'Ubicaci√≥n Pro'}</div>
                                            <div style={{ fontSize: 10, opacity: 0.6 }}>{coords || 'Detectando GPS...'}</div>
                                            </div>
                                            </div>
                                        );
                                    })()}
                                </div>
                            );
                        })}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};
ReactDOM.render(<DashboardApp />, document.getElementById('dashboard-root'));

            
            // Inicializar iconos despu√©s de que React termine
            setTimeout(() => { if(window.lucide) lucide.createIcons(); }, 500);
            
            console.log("‚úÖ ADTEC Dashboard: Renderizado exitoso.");
        } catch (err) {
            console.error("‚ùå Error Cr√≠tico Dashboard:", err);
            document.getElementById('error-fallback').style.display = 'block';
            document.getElementById('error-details').innerText = err.stack || err.message;
        }
    </script>
</body>
</html>